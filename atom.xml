<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jianier&#39;s blog</title>
  
  <subtitle>在bug中收获知识</subtitle>
  <link href="https://jianier.github.io/atom.xml" rel="self"/>
  
  <link href="https://jianier.github.io/"/>
  <updated>2021-05-30T11:46:11.417Z</updated>
  <id>https://jianier.github.io/</id>
  
  <author>
    <name>Yao Jiaying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息搜集</title>
    <link href="https://jianier.github.io/2021/05/30/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>https://jianier.github.io/2021/05/30/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2021-05-30T11:38:29.000Z</published>
    <updated>2021-05-30T11:46:11.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p>信息搜集也称<strong>踩点</strong>，占据整个渗透测试的百分之60</p><h3 id="信息搜集的分类"><a href="#信息搜集的分类" class="headerlink" title="信息搜集的分类"></a><strong>信息搜集的分类</strong></h3><ol><li><strong>主动式信息</strong>搜集–可获取到的信息较多，但易被目标发现</li><li>通过直接发起与被测目标网络之间的互动来获取相关信息，</li><li>被动式信息搜集</li></ol><h3 id="搜索引擎的一些语法"><a href="#搜索引擎的一些语法" class="headerlink" title="搜索引擎的一些语法"></a><strong>搜索引擎的一些语法</strong></h3><ol><li><strong>谷歌浏览器 Google hack</strong>  <a href="https://blog.csdn.net/u014565127/article/details/53868443">https://blog.csdn.net/u014565127/article/details/53868443</a></li></ol><ul><li><p>**inurl:**nuc.edu.cn 用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用。即搜索URL中包含有指定字符串的网址  inurl:php 问号id= 搜索PHP网页</p></li><li><p>**intext:**只搜索网页部分中包含的文字 //搜索站点正文中含有关键词的网页</p></li><li><p>**site:**可以限制你搜索范围的域名，即在指定站点内查找相关的内容</p></li><li><p>**filetype:**搜索文件的后缀或者扩展名,即搜索指定类型的文件</p></li><li><p>**intitle:**限制你搜索的网页标题</p></li><li><p>**allintitle:**搜索所有关键字构成标题的网页，但是不推荐使用</p></li><li><p>**link:**可以得到一个所有包含了某个指定URL的页面列表。例如:link;<a href="http://www.google.com就可以得到所有连接到goole的页面/">www.google.com就可以得到所有连接到Goole的页面</a></p></li><li><p><strong>模糊搜索</strong></p><ol><li><strong>同义词（波浪号）</strong><br>紧挨着关键词之前放波浪号 ~ 表示搜索同义词。<br>有了这个功能，你就不必用 OR 写一堆关键词。因为 Google 是足够聪明的，知道哪些词汇是近义词。<br>举例：如下语法，既可以搜索到包含 food 的网页，也可以搜索到包含 nutrition 的网页</li></ol><p>~food<br>请注意：这里的<strong>波浪号一定要用半角符号</strong>。</p><ol start="2"><li><strong>数字范围（两点</strong>）<br>在两个数字之间放两个小数点 .. 表示模糊搜索该数字范围。举例：</li></ol><p>世界杯 2002..2010<br>也可以仅指定一个数字，未指定的一端为无穷</p><p>请注意：这里的<strong>小数点一定要用半角符号</strong>。</p><ol start="3"><li><strong>通配符（星号）</strong><br>你可以用*<em>星号 **</em> 指代任何一个词汇。</li></ol><p>举例：比如新浪有如下几个域名 sina.com.cn、sina.com.hk、sina.com.tw，用如下语法，就可以限定搜索范围在上述几个域名</p><p>关键词 site:sina.com.*<br><strong>四、排除某些关键词</strong><br><strong>紧挨着关键词之前放减号</strong>，表示排除该关键词。也就是说，网页如果包含该关键词，就不会出现在搜索结果中。<br>举例：比如你搜索甲骨文，既找到“考古”方面的页面，也会找到“Oracle 数据库”方面的页面。如果你仅仅想要考古方面的，可以用如下方式排除数据库相关的结果。</p><p>甲骨文 -数据库<br><strong>五、括号的使用</strong><br>如果你需要混用上述几种语法，就得考虑使用括号——看起来清晰而且不容易搞错不同语法的优先级。举例：</p><p>关键词1 关键词2 (关键词3 OR 关键词4)</p></li></ul><ol start="2"><li><strong>Shodan</strong></li></ol><p>Shodan与Google这种搜索网址的搜索引擎不同的是，Shodan是用来搜索网络空间中在线设备的。</p><p>http.favicon.hash;’’-657477557’’ //哈希值  通过找网页源码</p><p>net.</p><ol start="3"><li><p><strong>Zoomeye</strong></p><p>Zoomeye是一款针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息。</p><p>country:’’China’’ 国家</p><p>city:’’hangzhou’’ 城市</p><p>app:nginx   服务器</p><p>port:3306   端口</p><p>ver:1.0  版本</p><p>os:windows 操作系统</p><p>hostname:nuc.edu.cn 主机名</p><p>service:ftp 服务</p><p>cidr:202.207.177.3/24 ip地址段</p><p>ip:202.207.177.3/24</p><p>keyword:</p><p>site:</p><p><strong>摄像头</strong></p></li><li><p><strong>fofa</strong></p></li><li><p><strong>爱企查、域名信息备案管理系统</strong></p></li></ol><p>供应链打击</p><p><strong>翻墙</strong>是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问；国内的用户想要访问国外的一些社交软件，但这些社交网站在国内是不能访问的，因此就出现了翻墙工具。</p><h3 id="渗透网站要收集什么"><a href="#渗透网站要收集什么" class="headerlink" title="渗透网站要收集什么"></a><strong>渗透网站要收集什么</strong></h3><p><strong>一.渗透网站要收集什么？</strong><br>判断：这些东西是否与目标有关。</p><ol><li><p><strong>whois</strong>：注册域名的时候留下的信息。比如域名注册人的邮箱、电话号码、姓名等。根据这些信息去尝试制作社工密码等。<br>站长之家域名whois查询：<a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a><br>whois查询：<a href="https://www.whois.com/">https://www.whois.com/</a><br>社工型密码：<a href="http://www.bugku.com/mima/">http://www.bugku.com/mima/</a></p></li><li><p><strong>子域名</strong>:（有概率同一台服务器，同一个管理）<br>在线平台ip反查域名：<a href="https://dns.aizhan.com/">https://dns.aizhan.com/</a><br>在线平台ip反查域名：<a href="https://reverseip.domaintools.com/">https://reverseip.domaintools.com/</a><br>微步社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br>站长工具：<a href="http://tool.chinaz.com/subdomain/">http://tool.chinaz.com/subdomain/</a></p></li><li><p><strong>旁站</strong>：<strong>同IP站点。同IP不代表同服务器</strong>。<strong>一定和目标站点在同一个内网或者是同一台服务器</strong><br>·旁站查询：<a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a><br>·在线工具：<a href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a><br>·在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p></li></ol><p><strong>谷歌语法 google hacking.内容敏感信息泄露</strong></p><p>site:</p><p>o指定域名<br>·<br>filetype:<br>·<br>o指定文件类型</p><p>inurl:<br>·<br>o指定URL<br>·<br>link:</p><p>o包含指定网页的链接的网页<br>·<br>intitle:<br>·<br>o指定title</p><p>intext:</p><p>o指定内容</p><ul><li><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">https://beian.miit.gov.cn/#/Integrated/recordQuery</a>   域名信息备案管理系统</li></ul><ul><li><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a>  钟馗之眼</li></ul><ul><li><a href="https://aiqicha.baidu.com/company_detail_85813027450209?tab=certRecord">https://aiqicha.baidu.com/company_detail_85813027450209?tab=certRecord</a>    爱企查 可以查到手机号邮箱等</li></ul><ul><li><a href="https://x.threatbook.cn/v5/domain/www.wenku8.com">https://x.threatbook.cn/v5/domain/www.wenku8.com</a>  微步在线</li></ul><ul><li><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a>   站长之家 — 站长之家whois查询（获取注册者邮箱姓名电话等</li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210526155706215.png" alt="gu"></p><p>谷歌语法</p><p>微博、抖音、微信</p><p>法人的微博账号</p><p>主域名去找子域名</p><p>谷歌浏览器安装插件</p><h3 id="域传送漏洞–可以到提交教育src漏洞的"><a href="#域传送漏洞–可以到提交教育src漏洞的" class="headerlink" title="域传送漏洞–可以到提交教育src漏洞的"></a><strong>域传送漏洞</strong>–可以到提交教育src漏洞的</h3><p>一个保存IP地址和域名相互映射关系的分布式数据库，重要的互联网基础设施，<strong>默认使用的TCP/UDP端口号是53</strong></p><p><strong>常见DNS记录类型:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A       IP地址记录,记录一个域名对应的IP地址</span><br><span class="line">AAAA    IPv6 地址记录，记录一个域名对应的IPv6地址</span><br><span class="line">CNAME   别名记录，记录一个主机的别名 </span><br><span class="line">MX      电子邮件交换记录，记录一个邮件域名对应的IP地址，如root@xxxx.com</span><br><span class="line">NS      域名服务器记录 ,记录该域名由哪台域名服务器解析</span><br><span class="line">PTR     反向记录，也即从IP地址到域名的一条记录</span><br><span class="line">TXT     记录域名的相关文本信息</span><br></pre></td></tr></table></figure><p><strong>域传送</strong> ：DNS Zone Transfer</p><p>DNS服务器分为：<strong>主服务器</strong>、<strong>备份服务器</strong>和<strong>缓存服务器</strong>。<br><strong>域传送</strong>是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。<br>在主备服务器之间同步数据库，需要使用“DNS域传送”。</p><h3 id="nslookup命令及nslookup漏洞"><a href="#nslookup命令及nslookup漏洞" class="headerlink" title="nslookup命令及nslookup漏洞"></a><strong>nslookup命令及nslookup漏洞</strong></h3><p><strong>Nslookup</strong>是一个监测网络中<strong>DNS服务器是否能正确实现域名解析</strong>的命令行工具。<strong>查询域名信息的一个非常有用的命令</strong>，可以指定查询的类型，可以<strong>查到DNS记录的生存时间</strong>还可以<strong>指定使用哪个DNS服务器进行解释</strong>。在已安装<a href="https://baike.so.com/doc/2883582-3043043.html">TCP/IP协议</a>的电脑上面均可以使用这个命令。主要用来诊断<a href="https://baike.so.com/doc/6112986-6326125.html">域名系统</a> (DNS) 基础结构的信息。</p><p>nslookup  -type=ns    nuc.edu.cn</p><p>nslookup是<strong>Windows自带的</strong></p><h3 id="子域名收集-帮助我们做一次准确的二级域名收集"><a href="#子域名收集-帮助我们做一次准确的二级域名收集" class="headerlink" title="子域名收集  帮助我们做一次准确的二级域名收集"></a>子域名收集  帮助我们做一次准确的二级域名收集</h3><p>nslookup使用；<a href="https://www.360kuai.com/pc/94703c64bd9aaeeb1?cota=4&amp;kuai_so=1&amp;tj_url=xz&amp;sign=360_57c3bbd1&amp;refer_scene=so_1">https://www.360kuai.com/pc/94703c64bd9aaeeb1?cota=4&amp;kuai_so=1&amp;tj_url=xz&amp;sign=360_57c3bbd1&amp;refer_scene=so_1</a></p><ol><li><p>查询IP地址</p><p>nslookup最简单的用法就是查询域名对应的IP地址，包括A记录和CNAME记录，如果查到的是CNAME记录还会返回别名记录的设置情况。其用法是：<br>　　<strong>nslookup 域名</strong><br><img src="https://img-blog.csdn.net/20150529105105935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2hhdGRheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></li><li><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210527093709637.png" alt="image-20210527093709637"></p></li><li><p>server 域名</p></li><li><p>ls 域名</p></li></ol><p><strong>泛解析</strong></p><h4 id="泛解析即泛域名解析。"><a href="#泛解析即泛域名解析。" class="headerlink" title="泛解析即泛域名解析。"></a><strong>泛解析即泛域名解析。</strong></h4><p>  所谓“泛域名解析”是指：利用*<em>通配符**</em>（星号）来做次级域名以实现所有的<strong>次级域名</strong>均指向<strong>同一IP地址</strong>。</p><p>比如说 <a href="http://www.aaa.com/">http://www.aaa.com/</a> 指向10.10.1.1ftp.aaa.com指向10.10.2.2如果这时候客户访问的是aaa.com或者error.aaa.com (这里error代表一个根本不存在的域名或者说是A记录）这个时候，如果dns服务器不支持泛解析的话，那么就无法访问aaa公司的网站，提示错误。如果支持泛解析的话，如果你访问的域名在dns服务器中没有A记录，比如fadsfdsafsdaf.aaa.com，它一样会跳转到 <a href="http://www.aaa.com/%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E4%B8%80%E4%BA%9B%E4%BA%BA%E8%BE%93%E9%94%99%E7%BD%91%E5%9D%80%E5%90%8E%E5%88%B0%E4%B8%8D%E4%BA%86%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BD%91%E7%AB%99%E8%80%8C%E6%8D%9F%E5%A4%B1%E4%BA%86%E6%BD%9C%E5%9C%A8%E7%9A%84%E5%AE%A2%E6%88%B7%E3%80%82%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%8C%BA%E5%88%AB%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%98%AF%EF%BC%9A*.%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%88%B0%E5%90%8C%E4%B8%80IP%E3%80%82">http://www.aaa.com/，出现公司的网站，而不用担心一些人输错网址后到不了公司的网站而损失了潜在的客户。泛域名解析域名域名解析的区别泛域名解析是：*.域名解析到同一IP。</a> 域名解析是：子域名.域名解析到同一IP。 注意：只有客户的空间是独立IP的时候泛域名才有意义。而域名解析则没有此要求</p><p><strong>与域名解析区别</strong></p><p>  泛域名解析是：*<strong>.域名</strong>解析到同一IP。</p><p>  域名解析是：<strong>子域名.域名</strong>解析到同一IP。</p><p><strong>域名分级</strong></p><p>任何连接到因特网上的主机或路由都有唯一层次结构的名字即域名(domain name)。</p><p>因特网采用层次树状结构命名方法。域是名字空间中一个可被管理的划分（按机构组织划分），域可被划分为子域，子域可再被划分，即形成了顶级域名、二级域名、三级域名等。从右向左为顶级域名、二级域名、三级域名等，用点隔开。如：<br>tieba.baidu.com<br>它由三个标号组成， com即为顶级域名，baidu为二级域名，tieba即为三级域名。且域名不分区大小写。<br>PS:没有一级域名的说法。<br>现在也有人把baidu.com连在一起称为二级域名，但从wiki定义上来说二级域名只是baidu而已。<br> 域名体系与域名解析流程<br>3.1 域名体系<br>上面只是从语法上对域名解析进行了分析，但实际上对域名解析真实流程应该有一个基础的概念。</p><p>我们可以用一个域名树来表示一个来表示域名网络结构，最上面的是根，但没有对应的名字。根下面一级的节点就是最高一级的顶级域名(因为根没名字，所以根下面一级域名就是顶级域名)。顶级域名往下划分就是二级域名，再往下划分就是三级四级域名。这里就解释了域名系统中根的概念。</p><p>![](C:\Users\Administrator\Pictures\Camera Roll\因特网的域名空间.png)</p><p>DNS域名服务器同样具有类似的结构</p><p>![](C:\Users\Administrator\Pictures\Camera Roll\树状结构的DNS域名服务器.png)</p><p>在图中每一个域名服务器都能进行部分域名到IP地址的解析，当某个DNS服务器不能进行域名到IP地址的转换时，它就会到网络上其他域名服务器进行解析。从图中也可看出，DNS域名服务器也是按照层次安排。每一个域名服务器都只对域名体系中的一部分进行管辖。</p><p><strong>子域名挖掘机Layer</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210527111225877.png" alt="image-20210527111225877"></p><h4 id="OneForAll–子域名挖掘工具https-github-com-shmilylty-OneForAll"><a href="#OneForAll–子域名挖掘工具https-github-com-shmilylty-OneForAll" class="headerlink" title="OneForAll–子域名挖掘工具https://github.com/shmilylty/OneForAll"></a><strong>OneForAll–子域名挖掘工具</strong><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></h4><p><strong>OneForAll使用：</strong></p><p>python oneforall.py –target  .\example.txt run <strong>批量I</strong>P地址扫描</p><p>我们以<code>python3 oneforall.py --target example.com run</code>命令为例，OneForAll在默认参数正常执行完毕会在results目录生成相应结果：</p><p><img src="F:\OneForAll-master\images\Result.png" alt="Result"></p><p><code>example.com.csv</code>是每个主域下的子域收集结果。</p><p><code>all_subdomain_result_1583034493.csv</code>是每次运行OneForAll收集到子域的汇总结果，包含<code>example.com.csv</code>，方便在批量收集场景中获取全部结果。</p><p><code>result.sqlite3</code>是存放每次运行OneForAll收集到子域的SQLite3结果数据库，其数据库结构如下图：</p><p><img src="F:\OneForAll-master\images\Database.png" alt="Database"></p><p><strong>pip镜像</strong>  国内清华大学的源<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p><p>安装出错  出现0x80070643  解决办法：<a href="https://www.cnblogs.com/emanlee/p/11422646.html">https://www.cnblogs.com/emanlee/p/11422646.html</a></p><h4 id="WebAliveScan下载"><a href="#WebAliveScan下载" class="headerlink" title="WebAliveScan下载"></a><strong>WebAliveScan下载</strong></h4><p>使用：</p><ul><li><p>增加忽略指定的HTTP状态</p></li><li><p>增加单个目标自定义端口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 webscan.py --target target.txt --port 80</span><br></pre></td></tr></table></figure></li><li><p>增加快速目录扫描</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">python3</span> <span class="comment">webscan</span><span class="string">.</span><span class="comment">py</span> --<span class="comment">target</span> <span class="comment">target</span><span class="string">.</span><span class="comment">txt</span> --<span class="comment">port</span> <span class="comment">80</span> --<span class="comment">brute</span> <span class="comment">True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以在rules</span><span class="string">.</span><span class="comment">py配置目录扫描的规则，这里的目录扫描目的是快速定位更脆弱的资产，跟传统的目录扫描有所不同</span></span><br><span class="line"><span class="comment">目前扫描规则包括ueditor、kindeditor、solr、axis、spring、weblogic</span></span><br></pre></td></tr></table></figure></li><li><p>增加简单的指纹识别、修改输出样式(<strong>指纹</strong>包括使用的框架、脚本语言、服务、系统等)</p></li></ul><p><strong>目录扫描</strong>的意义以及 <strong>二级域名</strong></p><p>目录扫描的作用点；</p><p>能找到更多有价值的信息，这些信息可能是我们无法直接从网站前台获取到的</p><p>有价值的信息；</p><ul><li>上传<ul><li>直接上传</li><li>间接上传</li></ul></li><li>管理后台</li><li>暴露处其他信息<ul><li>phpinfo页面</li><li>phpmyadmin登录页</li><li>网站相关配置信息</li><li>网站源码备份</li><li>更多其他信息</li></ul></li><li>更多其他分类信息</li></ul><p><strong>1、目录扫描：</strong></p><p><strong>扫描站点的目录，寻找敏感文件（目录名、探针文件、后台、robots.txt、备份文件等）。</strong></p><p><strong>2、目录：站点结构，权限控制不严格。</strong></p><p><strong>3、探针文件：服务器配置信息，例：phpinfo.php、readme.php、config.txt</strong></p><p><strong>4、后台：管理整个网站的入口，inurl:admin.php</strong></p><p><strong>5、rebots.txt：一般存放在站点根目录，如果管理员对robots.txt文件不合理就会造成信息泄露. 　　6、备份文件：数据库备份，网站备份文件等 .bak .zip <a href="http://www.rar/">www.rar</a></strong></p><p><strong>站库分离</strong>是指–网站和数据库分离</p><h4 id="nmap安装"><a href="#nmap安装" class="headerlink" title="nmap安装"></a><strong>nmap安装</strong></h4><p>Nmap是一款<strong>网络扫描和主机检测</strong>的非常有用的工具。Nmap是不局限于仅仅<strong>收集信息和枚举</strong>，同时可以用来作为一个<strong>漏洞探测器或安全扫描器。</strong></p><p>智能小技巧；<strong>excel表格 数据菜单栏选择导入数据可以根据空格拆分插入表格、去重复项点击数据菜单栏有去重</strong></p><p><strong>nmap命令</strong>  <a href="https://www.cnblogs.com/LyShark/p/10637507.html">https://www.cnblogs.com/LyShark/p/10637507.html</a></p><p><a href="https://blog.csdn.net/u012206617/article/details/85283595?utm_term=nmap%E6%89%AB%E6%8F%8F%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-85283595&amp;spm=3001.4430">https://blog.csdn.net/u012206617/article/details/85283595?utm_term=nmap%E6%89%AB%E6%8F%8F%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-85283595&amp;spm=3001.4430</a></p><ul><li><p><strong>nmap</strong> <strong>-iL</strong> ‘’C:\Users\Administrator\Desktop\1.txt’’  <strong>扫描文件里的IP</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210528144547060.png" alt="image-20210528144547060"></p></li><li><p><strong>netstat -ano</strong>    查看开放的端口  –溯源时要用的一个常用命令</p><ul><li>-l (listen) 仅列出 Listen (监听) 的服务</li><li>-t (tcp) 仅显示tcp相关内容</li><li>-n (numeric) 直接显示ip地址以及端口，不解析为服务名或者主机名</li><li>-p (pid) 显示出socket所属的进程PID 以及进程名字</li><li>–inet 显示ipv4相关协议的监听</li></ul></li><li><p><strong>nmap -iR 50  -p22 -open</strong></p></li><li><p><strong>nmap -iR 50  -p22</strong> 先看50个IP是否存活会发现50个IP里面只有6个存活，再看是否22端口开放</p></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210528145147071.png" alt="image-20210528145147071"></p><p><strong>Nmap通过探测将端口划分为6个状态：</strong><br>1、open：端口是开放的。<br>2、closed：端口是关闭的。<br>3、filtered：端口被防火墙IDS/IPS屏蔽，无法确定其状态。<br>4、unfiltered：端口没有被屏蔽，但是否开放需要进一步确定。<br>5、open|filtered：端口是开放的或被屏蔽。<br>6、closed|filtered ：端口是关闭的或被屏蔽。</p><p><strong>扫描多个IP可以用空格或者逗号，</strong></p><p><strong>扫描连续IP可以</strong>       nmap 10.0.1.161-162</p><p>**扫描一个子网网段所有IP **    nmap 10.0.3.0/24</p><p><strong>扫描地址段是排除某个IP地址</strong>    nmap 10.0.1.161-161 –exclude 10.0.1.162    可以防止扫描公用地址</p><p><strong>扫描多个地址时排除文件里的IP地址</strong>  nmap 10.0.1.161-163 –excludefile ex.txt</p><p><strong>排除分散的，使用逗号隔开</strong>   nmap 10.0.1.161-163 –exclude 10.0.1.161,10.0.1.163</p><p><strong>排除连续的，可以使用横线连接起来</strong>   nmap 10.0.1.161-163 –exclude 10.0.1.162-163</p><p><strong>计算网段主机IP: 仅列出指定网段上的每台主机,不发送任何报文到目标主机.</strong>     nmap -sL 192.168.109.1/24</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmap -sL 192.168.1.0/24</span></span><br><span class="line"></span><br><span class="line">Starting Nmap 6.40 ( http://nmap.org ) at 2019-03-19 21:43 EDT</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.0</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.1</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.2</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.3</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.4</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.5</span><br><span class="line">...省略...</span><br><span class="line">Nmap <span class="keyword">done</span>: 256 IP addresses (0 hosts up) scanned <span class="keyword">in</span> 4.03 seconds</span><br></pre></td></tr></table></figure><p><strong>只探测主机是否存活  不探测端口</strong>  nmap -sn 192.168.109.129/30  </p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210528152250511.png" alt="image-20210528152250511"></p><ul><li><p><strong>防止漏掉一些端口 无论是否防火墙开着或者端口是否开着</strong>  </p><p>nmap -Pn 192.168.109.129</p></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210528152644938.png" alt="image-20210528152644938"></p><ul><li><p><strong>只发送SYN包</strong> nmap -PS 192.168.109.129  –半扫描</p></li><li><p><strong>基于是否返回ACK包来看是否端口开放</strong>nmap -PA 192.168.109.132  –完全扫描</p></li><li><p><strong>udp包 断包可以，TCP不可以断包</strong>  nmap -PU 192.168.109.129</p></li><li><p>nmap -PY 192.168.109.129 </p></li><li><p>nmap -PE(ICMP ECHO 数据包回声请求  回声响应) 192.168.109.129 </p></li><li><p>nmap -PP 192.168.109.129   <strong>发送icmp的时间戳</strong></p></li><li><p>nmap -PM 192.168.109.129  <strong>使用 icmp的地址掩码发送给服务器</strong></p></li><li><p>-PE/-PP/-PM  使用ICMP echo、timestamp(时间戳)、查对方的子网掩码，通常差不多结果。除非对方是非常老而且非常不安全的系统</p></li><li><p>nmap -PO 192.168.109.129 <strong>通过IP协议扫描</strong></p></li><li><p>nmap -n 192.168.109.129   <strong>扫描不做DNS的解析</strong></p></li><li><p>nmap -R 192.168.109.129   <strong>扫描做DNS的解析</strong></p></li><li><p>nmap -dns–servers 192.168.109.129  <strong>调用指定DNS服务器。不使用默认的DNS</strong></p></li><li><p>nmap –system-dns 192.168.109.132  <strong>系统默认的DNS，与默认一样</strong></p></li><li><p>nmap <a href="http://www.baidu.com/">www.baidu.com</a> –traceroute    <strong>路由追踪表</strong> </p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210528160547317.png" alt="image-20210528160547317"></p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line"><span class="number">1</span>. <span class="keyword">nmap</span> -sT <span class="number">192.168</span>.<span class="number">96.4</span> //TCP连接扫描，不安全，慢</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>. <span class="keyword">nmap</span> -sS <span class="number">192.168</span>.<span class="number">96.4</span> //SYN扫描,使用最频繁，安全，快</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>. <span class="keyword">nmap</span> -Pn <span class="number">192.168</span>.<span class="number">96.4</span> //目标机禁用ping，绕过ping扫描，如果是在Internet的环境，而不是在局域网的环境，用这个命令扫描主机存活情况，不然很容易被防火墙丢包</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>. <span class="keyword">nmap</span> -sU <span class="number">192.168</span>.<span class="number">96.4</span> //UDP扫描,慢,可得到有价值的服务器程序</span><br><span class="line"> </span><br><span class="line"><span class="number">5</span>. <span class="keyword">nmap</span> -sI 僵尸ip 目标ip //使用僵尸机对目标机发送数据包</span><br><span class="line"> </span><br><span class="line"><span class="number">6</span>. <span class="keyword">nmap</span> -sA <span class="number">192.168</span>.<span class="number">96.4</span> //检测哪些端口被屏蔽</span><br><span class="line"> </span><br><span class="line"><span class="number">7</span>. <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.4</span> -<span class="keyword">p</span> //对指定端口扫描</span><br><span class="line"></span><br><span class="line"> <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.4</span> -p1-<span class="number">100</span> -r  -v按顺序扫描  -v显示详情</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.4</span> --top-ports <span class="number">10</span>最常见的前<span class="number">10</span>个漏洞--端口</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.4</span> --port-ratio <span class="number">0.1</span> 看比重的</span><br><span class="line"> </span><br><span class="line"><span class="number">8</span>. <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.1</span>/<span class="number">24</span> //对整个网段的主机进行扫描</span><br><span class="line"> </span><br><span class="line"><span class="number">9</span>. <span class="keyword">nmap</span> <span class="number">192.168</span>.<span class="number">96.4</span> -oX myscan.xml //对扫描结果另存在myscan.xml</span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>. <span class="keyword">nmap</span> -T1~<span class="number">6</span> <span class="number">192.168</span>.<span class="number">96.4</span> //设置扫描速度<span class="number">1</span>-<span class="number">6</span>。默认通常情况下无需选择扫描速度选项,除非想进行更隐匿或更快速的扫描，越快越容易被防火墙过滤或屏蔽，网络良好情况下T4足够。</span><br><span class="line"> </span><br><span class="line"><span class="number">11</span>. <span class="keyword">nmap</span> -sV <span class="number">192.168</span>.<span class="number">96.4</span> //对端口上的服务程序版本进行扫描</span><br><span class="line"> </span><br><span class="line"><span class="number">12</span>. <span class="keyword">nmap</span> -O <span class="number">192.168</span>.<span class="number">96.4</span> //对目标主机的操作系统进行扫描</span><br><span class="line"> </span><br><span class="line"><span class="number">13</span>. <span class="keyword">nmap</span> -sC <span class="number">192.168</span>.<span class="number">96.4</span> //使用脚本进行扫描，耗时长</span><br><span class="line"> </span><br><span class="line"><span class="number">14</span>. <span class="keyword">nmap</span> -A <span class="number">192.168</span>.<span class="number">96.4</span> //强力扫描，耗时长</span><br><span class="line"> </span><br><span class="line"><span class="number">15</span>. <span class="keyword">nmap</span> -<span class="number">6</span> ipv6地址 //对ipv6地址的主机进行扫描</span><br><span class="line"> </span><br><span class="line"><span class="number">16</span>. <span class="keyword">nmap</span> -<span class="keyword">f</span> <span class="number">192.168</span>.<span class="number">96.4</span> //使用小数据包发送，避免被识别出</span><br><span class="line"> </span><br><span class="line"><span class="number">17</span>. <span class="keyword">nmap</span> –mtu <span class="number">192.168</span>.<span class="number">96.4</span> //发送的包大小,最大传输单元必须是<span class="number">8</span>的整数</span><br><span class="line"> </span><br><span class="line"><span class="number">18</span>. <span class="keyword">nmap</span> -D &lt;假ip&gt; <span class="number">192.168</span>.<span class="number">96.4</span> //发送参杂着假ip的数据包检测</span><br><span class="line"> </span><br><span class="line"><span class="number">19</span>. <span class="keyword">nmap</span> --<span class="keyword">source</span>-port //针对防火墙只允许的源端口</span><br><span class="line"> </span><br><span class="line"><span class="number">20</span>. <span class="keyword">nmap</span> –data-length: <span class="number">192.168</span>.<span class="number">96.4</span> //改变发生数据包的默认的长度，避免被识别出来是<span class="keyword">nmap</span>发送的。</span><br><span class="line"> </span><br><span class="line"><span class="number">21</span>. <span class="keyword">nmap</span> -v <span class="number">192.168</span>.<span class="number">96.4</span> //显示冗余信息(扫描细节)</span><br><span class="line"> </span><br><span class="line"><span class="number">22</span>. <span class="keyword">nmap</span> -<span class="keyword">sn</span> <span class="number">192.168</span>.<span class="number">96.4</span> //对目标进行ping检测，不进行端口扫描（会发送四种报文确定目标是否存活,）</span><br><span class="line"> </span><br><span class="line"><span class="number">23</span>. <span class="keyword">nmap</span> -sP <span class="number">192.168</span>.<span class="number">96.4</span> //仅仅对目标进行ping检测。</span><br><span class="line"> </span><br><span class="line"><span class="number">24</span>. <span class="keyword">nmap</span> -n/-<span class="keyword">p</span> <span class="number">192.168</span>.<span class="number">96.4</span> //-n表示不进行dns解析，-<span class="keyword">p</span>表示要</span><br><span class="line"> </span><br><span class="line"><span class="number">25</span>. <span class="keyword">nmap</span> --<span class="built_in">system</span>-dns <span class="number">192.168</span>.<span class="number">96.4</span> //扫描指定系统的dns服务器</span><br><span class="line"> </span><br><span class="line"><span class="number">26</span>. <span class="keyword">nmap</span> –traceroute <span class="number">192.168</span>.<span class="number">96.4</span> //追踪每个路由节点。</span><br><span class="line"> </span><br><span class="line"><span class="number">27</span>. <span class="keyword">nmap</span> -PE/PP/PM: 使用ICMP <span class="keyword">echo</span>, timestamp, <span class="built_in">and</span> netmask 请求包发现主机。</span><br><span class="line"> </span><br><span class="line"><span class="number">28</span>. <span class="keyword">nmap</span> -sP <span class="number">192.168</span>.<span class="number">96.4</span> //主机存活性扫描，arp直连方式。</span><br><span class="line"> </span><br><span class="line"><span class="number">29</span>. <span class="keyword">nmap</span> -iR [<span class="keyword">number</span>] //对随机生成<span class="keyword">number</span>个地址进行扫描。</span><br><span class="line"> </span><br><span class="line"><span class="number">30</span>. <span class="keyword">nmap</span> -<span class="keyword">p</span> //端口范围：指定端口</span><br><span class="line"> </span><br><span class="line"><span class="number">31</span>.<span class="keyword">nmap</span> -F（快速扫描）//仅扫描常用的<span class="number">100</span>个端口。</span><br><span class="line"> </span><br><span class="line"><span class="number">32</span>. <span class="keyword">nmap</span> -r（顺序扫描）//按照从小到大的顺序进行端口扫描。</span><br><span class="line"> </span><br><span class="line"><span class="number">33</span>. <span class="keyword">nmap</span> -iL 文件名 //扫描外部文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>管道符</strong> </p><p>closed | filtered</p><ul><li><p><strong>端口发现–扫描技术</strong></p><ul><li><p>-sS/sT/sW/sM默认使用SYN扫描/TCP扫描，建立完整的会话/发一个ACK，配合 SYN可以探测防火墙规则/TCP中的窗口扫描/ACK和Fin组合</p></li><li><p>-sU使用UDP协议扫描</p></li><li><p>-sN/sF/sX  TCP flag全空/只有Fin/urgent、push、fin组合</p></li><li><p>–scanflags了解其中原理使用</p></li><li><p>-sI  僵尸扫描</p></li><li><p>-sY SCTP协议，用的极少</p><p>SCTP协议是一种传输协议，在TCP/IP协议栈中所处的位置和TCP、UDP类似，兼有TCP/UDP两者特征。</p><p><strong>TCP是以字节为单位传输的，SCTP是以数据块为单位传输的</strong></p><p> <strong>TCP通常是单路径传输，SCTP可以多路径传输</strong></p></li><li><p>-sO ip扫描</p></li></ul></li><li><p><strong>端口规格和扫描顺序</strong></p><ul><li><p>nmap -p T:21 192.168.1.103</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529103855696.png" alt="image-20210529103855696"></p></li><li><p>–exclude-ports 标记不想扫描的端口</p></li><li><p><strong>-F</strong>快速模式扫描，默认不指定端口，nmap会扫描1000个常用端口，加上这个参数会比1000个端口更少</p></li><li><p>-r扫描端口时顺序扫描，默认是 不是顺序的</p></li><li><p>–top-ports nmap中默认1000个端口的选择  –top-ports 10 就是前十个常见的漏洞即端口</p><p>nmap 192.168.1.103  –top-ports 10</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529095117206.png" alt="image-20210529095117206"></p></li><li><p>nmap 10.0.183.181 –port-ratio 0.4</p></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529100723958.png" alt="image-20210529100723958"></p><h4 id="探测端口服务"><a href="#探测端口服务" class="headerlink" title="探测端口服务"></a><strong>探测端口服务</strong></h4><ul><li>nmap  -sV  192.168.109.132 </li></ul></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529101314305.png" alt="image-20210529101314305"></p><ul><li>nmap 192.168.109.132 -sV –version-intensity 2</li><li>nmap 192.168.109.132 -sV –version-all</li><li>nmap 192.168.109.132 -sV –version-trace <strong>可以看到扫描的过程</strong></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529102002276.png" alt="image-20210529102002276"></p><h4 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a><strong>脚本扫描</strong></h4><ul><li><p><strong>sC添加脚本</strong>，等于–script=xxx 添加脚本名称即可</p><p>nmap 192.168.109.132 –script=ventrilo-info.nse脚本名字</p><p>–script-args 后面加参数</p><p>–script-trace脚本追踪</p><p>–script-updatedb 更新脚本命令</p><p>–script-help=http-xssed.nse</p><p>script目录：ls/usr/share/nmap/script</p><p>nmap –script-help=http-xssed.nse</p></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529102431664.png" alt="image-20210529102431664"></p><h5 id="nmap-192-168-109-132-–script-ventrilo-info-nse-vv显示详细的信息第一行"><a href="#nmap-192-168-109-132-–script-ventrilo-info-nse-vv显示详细的信息第一行" class="headerlink" title="nmap 192.168.109.132 –script=ventrilo-info.nse -vv显示详细的信息第一行"></a>nmap 192.168.109.132 –script=ventrilo-info.nse <strong>-vv显示详细的信息第一行</strong></h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529102820594.png" alt="image-20210529102820594"></p><h4 id="检测操作系统https-blog-csdn-net-qq-26090065-article-details-80285088"><a href="#检测操作系统https-blog-csdn-net-qq-26090065-article-details-80285088" class="headerlink" title="检测操作系统https://blog.csdn.net/qq_26090065/article/details/80285088"></a><strong>检测操作系统</strong><a href="https://blog.csdn.net/qq_26090065/article/details/80285088">https://blog.csdn.net/qq_26090065/article/details/80285088</a></h4><ul><li><p>nmap 192.168.109.129 -0 -osscan-limit   限制nmap只对确定主机进行os探测(至少需确知该主机分别有一个open何closed的端口)</p></li><li><p>nmap 192.168.109.129 -0 -osscan-guess 大胆猜测对方主机的系统类型。由此准确性会下降不少，但会尽可能多为用户提供潜在的操作系统</p><h4 id="时间和性能"><a href="#时间和性能" class="headerlink" title="时间和性能"></a><strong>时间和性能</strong></h4><ul><li>**-T 0-5 ,一般选择4 **  设置时序模块，越高越快</li></ul></li><li><p>nmap –min-hostgroup 15     10.0.183.1/24 -F  最少一组扫描多少主机，</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529143404156.png" alt="image-20210529143404156"></p></li><li><p>nmap –max-hostgroup 15     10.0.183.1/24 -F  最多一组扫描多少主机，指定最小、最大的并行主机扫描组大小</p></li><li><p>nmap –min-parallelism 30     10.0.183.1/24 指定最小、最大并行探测数量</p></li><li><p>–min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout指定最小、最大的扫描往返时间</p><p>–min-rtt-timeout 3 192.168.109.132</p></li><li><p>nmap –max-retries 30     10.0.183.1/24  指定最大的重发扫描包的次数</p></li><li><p>nmap –host-timeouot 3     10.0.183.1/24  指定超时时间</p></li><li><p>nmap –scan-delay/–max-scan-delay  5 192.168.109.129/28 扫描延迟时间/最大延迟多少，指定每次探测延迟多长时间，即两次探测之间间隔多少时间</p></li><li><p>–min-rate 每秒发包不少于</p></li><li><p>–max-rate 每秒发包不大于</p></li></ul><h4 id="绕过防火墙和IDS欺骗"><a href="#绕过防火墙和IDS欺骗" class="headerlink" title="绕过防火墙和IDS欺骗"></a><strong>绕过防火墙和IDS欺骗</strong></h4><ul><li><p>-f  –mtu  一个传输路径上最大传输单元是由最小的mtu设备决定的</p><p>nmap -f 192.168.109.129</p><p>–mtu 设置MTU最大传输单元   类似于木桶原理</p></li></ul><p>​      nmap  -mtu   16   192.168.109.129</p><ul><li>nmap -D 192.168.109.129**,**10.0.193.161  伪造多个IP地址和源地址一同发送包，从而隐藏在众多的IP地址中而不易被发现。通过增加噪声IP，增加网络管理员工作成本。</li><li>nmap -S 192.168.109.129 伪造源地址，欺骗源地址</li></ul><p>​       nmap -S 192.126.1.11 -e eth0 192.168.1.103</p><ul><li><p>nmap -e 192.168.109.129**,**10.0.193.161    使用指定的接口  </p></li><li><p>nmap -g 192.168.109.129  使用指定的（输出）源端口</p></li><li><p>nmap  192.168.109.129 –data=fffffffffff  发送包的数据字段中追加自定义的ASCII字符串</p></li><li><p>nmap 192.168.109.129 –ttl 6 设置TTL值</p></li><li><p>nmap 192.168.109.129 –spoof-mac  00:00:00:00:00:00</p><p>伪造源Mac地址</p></li><li><p>nmap 192.168.109.129  –badsum </p><p>发送伪造TCP/UDP/SCTP校验和Checksum的数据包</p><p>每一个数据包都会有checksum的值，对包的完整性进行校验，故意发坏的欺骗防火墙 IDS</p></li></ul><h4 id="输出报告"><a href="#输出报告" class="headerlink" title="输出报告"></a>输出报告</h4><ul><li>nmap 10.0.183.1/24 <strong>-oX</strong> 333.xml -F</li></ul><p><code>oN/-oX/-oS/-oG &lt;file&gt;</code>：分别输出正常、XML、s|</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210529160952211.png" alt="image-20210529160952211"></p><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul><li>-6 IPV6扫描</li><li>-A 是  -O、-sV、-script、-traceroute组合</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息搜集&quot;&gt;&lt;a href=&quot;#信息搜集&quot; class=&quot;headerlink&quot; title=&quot;信息搜集&quot;&gt;&lt;/a&gt;信息搜集&lt;/h1&gt;&lt;p&gt;信息搜集也称&lt;strong&gt;踩点&lt;/strong&gt;，占据整个渗透测试的百分之60&lt;/p&gt;
&lt;h3 id=&quot;信息搜集的分类&quot;&gt;</summary>
      
    
    
    
    <category term="信息搜集" scheme="https://jianier.github.io/categories/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="https://jianier.github.io/2021/05/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://jianier.github.io/2021/05/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-05-30T09:03:34.000Z</published>
    <updated>2021-05-30T09:03:53.383Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>开源</strong></p></li><li><p><strong>黑客</strong></p></li><li><p><strong>骇客</strong></p></li><li><p><strong>白帽子</strong></p></li><li><p><strong>灰帽子</strong></p></li><li><p><strong>脚本(asp、php、jsp)</strong></p></li><li><p><strong>HTML(css、js、HTML)是标记语言不是编程语言</strong></p></li><li><p><strong>架构</strong></p></li><li><p><strong>CMS：内容管理系统</strong></p></li><li><p><strong>MD5在线加密</strong></p></li><li><p><strong>肉鸡</strong>：被黑客入侵并长期控制的计算机或服务器</p></li><li><p><strong>抓鸡</strong>：利用使用量大的程序漏洞，使用自动化方式获取肉鸡的行为</p></li><li><p><strong>webshell</strong></p></li><li><p><strong>端口服务</strong></p><table><thead><tr><th>服务</th><th>端口</th></tr></thead><tbody><tr><td>FTP(文件传输)</td><td>21</td></tr><tr><td>Telnet远程登陆</td><td>23</td></tr><tr><td>SOCKS代理协议服务器</td><td>1080</td></tr><tr><td>HTTP</td><td>80/8080/3128/8081/9098</td></tr><tr><td>HTTPS</td><td>443</td></tr><tr><td>POP3</td><td>110</td></tr><tr><td>TFTP</td><td>69</td></tr><tr><td>SSH(安全登录)、SCP(文件传输)、端口重定向</td><td>22</td></tr><tr><td>JBOSS</td><td>8080</td></tr><tr><td>TOMCAT</td><td>8080</td></tr><tr><td>WIN2003</td><td>3389</td></tr><tr><td>ORACLE数据库</td><td>1521</td></tr><tr><td>SQL server</td><td>1433</td></tr><tr><td>SMTP</td><td>25</td></tr><tr><td></td><td></td></tr></tbody></table></li><li><p><strong>相对路径和绝对路径</strong></p><p>绝对路径；是指文件在硬盘上真正存在的路径。</p><p>绝对路径的缺点； 事实上，在网页编程时，很少会使用绝对路径，如果使用“E:\book\网页布\代码\第2章\bg.jpg”来指定背景图片的位置，在自己的计算机上 浏览可能会一切正常，但是上传到Web服务器上浏览就很有可能不会显示图片了。因为上传到Web服务器上时，可能整个网站并没有放在Web服务器的E盘， 有可能是D盘或H盘。即使放在Web服务器的E盘里，Web服务器的E盘里也不一定会存在“E:\book\网页布局\代码\第2章”这个目录，因此在浏 览网页时是不会显示图片的。</p><p>相对路径，就是相对于自己的目标文件位置。</p><p><strong>注意：</strong></p><ol><li>相对路径使用“/”字符作为目录的分隔字符，而绝对路径可以使用“\”或“/”字符作为目录的分隔字符。</li><li>在 相对路径里常使用“../”来表示上一级目录。</li></ol></li><li><p><strong>漏洞</strong>：硬件、软件、协议等等可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等</p></li><li><p><strong>端口</strong>；端口可分为虚拟和物理端口。</p><p><strong>虚拟端口</strong>指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口等</p><p><strong>物理端口</strong>又称为接口，是可见端口，计算机背板的RJ45网口等</p></li><li><p><strong>网关</strong>(应用层）：网关(Gateway)又称<a href="https://baike.baidu.com/item/%E7%BD%91%E9%97%B4%E8%BF%9E%E6%8E%A5%E5%99%A8/2943752">网间连接器</a>、协议转换器。默认网关在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C">网络</a>层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>类似，不同的是互连层。网关既可以用于<a href="https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91">广域网</a>互连，也可以用于<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>互连 。</p></li><li><p><strong>跳板</strong>；简单的来说，就是为了隐藏自己的地址，使用以及被控制的机器来攻击其他目标，让别人无法查找到自己的位置</p></li><li><p><strong>旁站</strong>：即同服务器下的网站</p></li><li><p><strong>旁站入侵</strong>：即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限</p></li><li><p><strong>C段</strong>；比如；1.1.1.1，最后一个是C段  如1.1.10/1.1.1.255这个C段有255个B 段有65535个 </p></li><li><p><strong>IP地址中的保留地址</strong>：</p></li><li><p>区分为<strong>静态</strong>和<strong>动态DHCP</strong>(动态主机配置协议)</p></li><li><p>**动态DHCP(动态主机配置协议)**：是一个局域网的网络协议，指的是有服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p></li><li><p><strong>服务</strong></p></li><li><p><strong>权限</strong></p></li><li><p><strong>批处理文件</strong></p></li><li><p><strong>渗透测试</strong></p></li><li><p><strong>APT攻击</strong></p><p>即高级可持续威胁攻击，也称为定向威胁攻击，指某组织对特定对象展开的持续有效的公祭活动。这种公祭活动具有极强的隐蔽性和针对性，通常会运用受感染的各种介质、供应链和社会工程学等多种手段实施先进 的、持续性且有效的威胁和攻击</p><ul><li>极强的隐蔽性</li><li>潜伏期长、持续性强</li><li>目标性强</li></ul></li><li><p><strong>EXP 、  POC  、VPS</strong></p><p>exp攻击   poc检测  ping vps 跳板机</p></li><li><p><strong>HTTP常见的14种状态码大全</strong></p><table><thead><tr><th></th><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1XX</td><td>Information(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>400</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>请求要求用户的身份证认证</td></tr><tr><td>403</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>服务器无法根据客户端的请求找到资源(网页)。</td></tr><tr><td>405</td><td>客户端请求中的方法被禁止</td></tr><tr><td>500</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>201</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其URI已经随location头信息返回。</td></tr><tr><td>300</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。</td></tr></tbody></table></li><li><p><strong>静态网站</strong>；是指全部由HTML代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种</p></li><li><p><strong>动态网站</strong>；并不是指具有动画功能的网站，而是指网站内容可根据不同情况动态变更的网站，一般情况下动态网站通过数据库进行架构。</p><p>动态网站体现在一般是以asp、jsp  php aspx等技术，静态网站一般是以HTML结尾</p></li><li><p><strong>伪静态网站</strong>；</p><p>伪静态是相对于真实静态而言的，通常我们为了增强搜索引擎的友好面，都将文章内容生成静态页面，但是有的朋友为了实时的显示一些信息，或者还想运用动态脚本解决一些问题。</p><p><strong>本质就是URL重写方式，写的看起来是个静态页面，并不是真的静态。</strong></p></li><li><p><strong>ARP欺骗</strong>–》回应每个请求。</p></li><li><p>![](C:\Users\Administrator\Pictures\Camera Roll\网络七层.jpg)</p></li></ul><h2 id="Burp-Suite中intruder爆破模块四种模式的区别"><a href="#Burp-Suite中intruder爆破模块四种模式的区别" class="headerlink" title="Burp Suite中intruder爆破模块四种模式的区别"></a>Burp Suite中intruder爆破模块四种模式的区别</h2><ol><li><p><strong>Sniper狙击手</strong></p><p>顾名思义就是一个一个的来，添加了一个参数的话，并且假设payload有500个的话，那就执行500次</p><p>如果添加了两个参数的话，就会挨着来，第一个参数开始爆破时，第二个不变，如此如此，会进行500+500此  总共1000次爆破</p></li><li><p><strong>Battering ram 攻城锤</strong></p><p>顾名思义，和狙击手差不多，一个参数的话都一样，只不过如果添加了两个参数的话，就一起进行爆破。那么两个参数爆破时候的值肯定就是一样的了。那么就只会进行500次爆破。</p></li><li><p><strong>Pitchfork 草叉模式</strong></p><p>此模式下如果只添加了一个参数的话，会报错</p><p>添加了两个参数的话，要求添加两个payload</p><p>pl 1，2</p><p>pl  3，4</p><p>那么第一次爆破为1，3</p><p>而第二次爆破为2，4</p><p>如果两个payload行数不一致的话，<strong>取最小值进行测试。所以爆破的次数取两个中最小的为准</strong>。</p></li><li><p><strong>Cluster bomb集束炸弹</strong></p><p>同pitchfork，起码两个参数，但此操作会计算两个的payload的<strong>笛卡尔积</strong></p><p>比如；pl 1,2,3</p><p>pl2 4,5,6</p><p>那么第一次爆破为1，4</p><p>第二次为1，5</p><p>以此类推 1，6</p><p>2，4</p><p>2，5。。。。。</p></li></ol><ul><li><p><strong>IP地址中的保留地址</strong></p><p>区分A类 和A段</p><p><strong>保留地址的分配</strong></p><p>互联网上的IP地址统一由一个叫IANA(Internet Assigned Numbers Authority互联网网络号分配机构)的组织来管理。根据用途和安全性级别的不同，IP地址还可以大致分为两类：<strong>公有地址</strong>和<strong>私有地址</strong>。<strong>公有地址在Internet中使用</strong>，可以在Internet中随意访问。<strong>私有地址只能在内部网络中使用</strong>，只有通过代理服务器才能与Internet通信。</p><p>一个机构网络要连入Internet，必须申请公用IP地址。但是考虑到网络安全和内部实验等特殊情况，在IP地址中专门保留了三个区域作为私有地址，其地址范围如下：</p><table><thead><tr><th>网络类别</th><th>IP地址范围</th><th>网络数</th></tr></thead><tbody><tr><td>a类网</td><td>10.0.0.0~10.255.255.255</td><td>1</td></tr><tr><td>b类网</td><td>172.16.0.0~172.31.255.255</td><td>16</td></tr><tr><td>c类网</td><td>192.168.0.0~192.168.255.255</td><td>255</td></tr></tbody></table><p>使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其他网络使用，如果进行网络互连，那么寻找路由就会因为地址不唯一而出现问题。但是这些使用保留地址的网络可以通过将本网络内的保留地址翻译转换成公共地址的方式实现与外部网络的互连。这也是保证网络安全的重要方法之一。</p><p>保留的IP地址段不会在互联网上使用，因此与广域网相连的路由器在处理保留IP地址时，只是想该数据包丢弃处理，而不会路由到广域网上去，从而将保留地址产生的数据隔离在局域网内部。</p><p><strong>特殊的IP地址</strong></p><ol><li><p><strong>0.0.0.0</strong></p><p>严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。他表示的是这样的一个集合；所有不清楚的主机和目的网络。这里的’不清楚‘’是指在本机的路由表里没有特定条目指明如何到达。对本机来说，他就是一个‘收容所’‘，所有不认识的’‘三无’‘人员，一律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路径。</p></li><li><p><strong>255.255.255.255</strong></p><p>限制广播路径。对本机来说，这个地址指本网段内–同一广播域内的所有主机。如果翻译成人类的语言，应该是这样’‘这个房间里的所有人都注意了这个地址不能被路由器转发</p></li><li><p><strong>127.0.0.1</strong></p><p>本机地址，主要用于测试。用汉语表示，就是’‘我自己’‘。在Windows系统中，这个地址有一个别名‘’localhost‘’。寻址这样一个地址，是不能把它发送到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为‘’127.0.0.1‘’的数据包。</p></li><li><p><strong>224.0.0.1</strong></p><p>组播地址，注意他和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP—Internet路由发现协议，使用组播功能，那么拟端主机路由器表中应该有这样一条路由。</p></li><li><p><strong>169.254.x.x</strong></p><p>如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超过一个系统规定的时间，Windows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。</p></li><li><p><strong>10.x.x.x    172.16.x.x–172.31.x.x    192.168.x.x</strong></p><p><strong>私有地址，这些地址被大量用于企业内部网络中。</strong>一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互联，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私有网络在接入Internet，要使用地址翻译NAT，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。</p><p>对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种；本机IP地址，广播地址以及组播地址。</p></li></ol></li><li><p><strong>HTTP协议基础</strong></p></li></ul><ul><li><p><strong>http消息头</strong></p><ul><li><strong>accept</strong>  设置接受的</li><li><strong>accept-encoding</strong></li><li><strong>accept-language</strong></li><li><strong>authorization</strong></li><li><strong>cache-control</strong></li><li><strong>connection</strong></li></ul></li><li><p><strong>HTTP方法</strong></p><ul><li><strong>GET</strong> </li><li><strong>post</strong>   </li><li><strong>head</strong>   返回报文的头部</li><li><strong>trace</strong></li><li><strong>options</strong> 客户端询问服务器可以提交哪些请求方法</li><li>**put **    向指定的目录上传文件</li></ul></li><li><p><strong>web渗透中不安全的HTTP方法</strong></p><p>HTTP通常有GET、POST、<strong>DELETE</strong>、OPTIONS、<strong>PUT</strong>、PATCH五种，当然也有拓展的。我们将<strong>PUT、DELETE这种明显含有上传和删除文件权限的方法称作不安全的HTTP方法。</strong></p><p>好了，不废话。平常我是怎么测试，通过GET请求访问一个网页，抓包然后将GET请求替换为OPTIONS方法，这时服务器通常会返回对于接口资源的支持，而开启哪些HTTP方法也包含其中。</p></li></ul><p>![](C:\Users\Administrator\Pictures\Camera Roll\web渗透中不安全的HTTP方法.png)</p><ul><li><p><strong>HTTP和HTTPS的区别</strong></p><p><strong>https的作用：</strong></p><ul><li><p>CIA：机密性、完整性、可用性(信息传输中)</p></li><li><p>解决的是信息传输过程中数据被篡改、窃取</p></li><li><p>只解决了数据传输过程中的机密性和完整性</p></li><li><p><strong>在客户端和服务端中的任何一个节点都可以把自己做成中间人的模式进行监听</strong></p></li><li><p><strong>客户端—-中间人(解密https查看之后)–服务端</strong></p></li><li><p><strong>正常情况下，客户端向服务端发起访问请求，发起请求之后服务端将含有公钥的证书下发给客户端，客户端拿到公钥证书之后随即在客户端生成一个对称密钥。通过这个对称密钥来加密后续的数据流量。但是对称密钥不会在网络中直接传输，对称密钥会用证书中的公钥把对称密钥加密发送给服务器端，服务器端有自己证书公钥对应的私钥，只有服务器端解出来客户端发来的数据，解出来之后就拿到加密数据的对称密钥，后续的数据还是使用对称加密密钥进行，因为每次会话的对称密钥都是客户端随机生成，所以一次通讯完成之后就会失效。时效短破解比较安全。</strong></p></li><li><p><strong>客户端—中间节点–服务器端</strong></p></li><li><p>黑客会在中间节点劫持时使自己的服务器上生成一张证书，伪造证书会按照服务器端的字段生成一个证书，伪造证书和真正的服务器端的证书公私钥是不一样的，<strong>因为公私钥是由非对称的加密算法来进行生成的，一个公钥加密的内容只有对应的私钥可以解开，所以公钥可以拿来给人，但是私钥要自己保存。</strong></p></li><li><p>伪造证书的作用；客户端访问访问服务器端时，其实是先访问了劫持者</p></li><li><h3 id="SeesionId-Token以及公私钥，服务端与客户端自己的交互"><a href="#SeesionId-Token以及公私钥，服务端与客户端自己的交互" class="headerlink" title="SeesionId ,Token以及公私钥，服务端与客户端自己的交互"></a>SeesionId ,Token以及公私钥，服务端与客户端自己的交互</h3><ul><li><p>登录机制主要分为登录验证、登录保持、登出三个部分。</p></li><li><p><strong>登录验证</strong></p><ol><li><p>密码传输</p><p>客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：</p><ul><li>客户端向服务器第一次发起登录请求（<strong>不传输用户名和密码）。</strong></li><li><strong>服务器</strong>利用RSA算法产生一对公钥和私钥。<strong>并保留私钥</strong>， <strong>将公钥发送给客户端</strong>。</li><li>客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。</li><li><strong>服务器利用保留的私钥对密文进行解密，得到真正的密码。</strong></li></ul></li><li><p><strong>登录状态token</strong></p><p>再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。</p><ul><li><p>客户端向服务器第一次发起登录请求（不传输用户名和密码）。</p></li><li><p>服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。</p></li><li><p>客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。</p></li><li><p>服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。</p></li><li><p>客户端利用自己生成的私钥对token密文解密， 得到真正的token。</p><p>![](C:\Users\Administrator\Pictures\Camera Roll\公钥私钥.png)</p></li></ul></li><li><p><strong>登录保持</strong></p><p>在最原始的方案中， 登录保持仅仅靠服务器生成的sessionId: 客户端的请求中带上sessionId, 如果服务器的redis中存在这个id，就认为请求来自相应的登录客户端。 但是只要sessionId被截获， 请求就可以为伪造， 存在安全隐患。</p><p>引入token后，上述问题便可得到解决。 服务器将token和其它的一些变量， 利用散列加密<a href="http://lib.csdn.net/base/31">算法</a>得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token,利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端。<a href="http://nmgfrank.com/wp-content/uploads/2015/07/keep_login.png"><img src="http://nmgfrank.com/wp-content/uploads/2015/07/keep_login-300x131.png" alt="keep_login"></a></p></li><li></li></ol></li><li></li></ul></li></ul></li><li><p><strong>死亡之ping</strong>（ping of death）：ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)</p></li></ul><p><strong>常见Dos攻击原理及防护（死亡之Ping、Smurf、Teardown、LandAttack、SYN Flood）</strong></p><p><strong>DoS是Denial of Service的简称</strong>，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p><p>burpsuite手机抓包</p><p>手机安装burp证书</p><p><strong>sessionid和token的区别；</strong></p><p><strong>ping</strong></p><p>ping用于确定本地主机是否与另一台主机成功交换数据包，再根据返回的信息，就可以推断出TCP/IP参数是否设置正确、网络是否畅通等。</p><p><strong>dns</strong>—域名翻译成IP</p><p>工作原理；可以把dns看成是你手机中的 通讯录，通讯录中有人名，人名对应手机号码等联系方式；当你想打电话给某个人时，在通讯里中输入那个人的名称，就好像你的浏览器中输入域名url。然后通讯录检索到你输入的那个人名，然后返回那个人的电话号码，换成dns，就是dns将你输入的url对应成IP地址，然后将IP地址返回给服务器，从而帮助用户获取网页内容。</p><p><strong>cdn</strong>—内容分发网络–通俗理解就是<strong>网站加速</strong>，可以解决跨运营商，跨地区，服务器负载能力过低，带宽过少等带来的网站打开速度慢等问题。</p><p>例子；比如：</p><p>1.一个企业的网站服务器在北京，运营商是电信，在广东的联通用户访问<a href="https://baike.so.com/doc/404357.html">企业网站</a>时，因为跨地区，跨运营商的原因，网站打开速度就会比北京当地的电信客户访问速度慢很多，很容易造成这个企业的客户流失</p><p>2.一个网站的服务器性能比较差，承载能力有限，有时面临突发流量，招架不住，直接导致服务器崩溃，网站打不开，尤其是电商网站在节日期间，因为这种情况网站打不开，销售额白白流失的占比都高涨至60%</p><p>3.再比如一些中小企业租用的<a href="https://baike.so.com/doc/2724947.html">虚拟主机</a>，因为跟好几个网站共用一台服务器，每个网站所分带宽有限，带宽过小经常导致流量稍微一多，网站打开速度就很慢，甚至打不开</p><p>其<strong>基本思路</strong>是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p><strong>cookie和session的区别</strong></p><p>比如说，客户端要访问服务端的资源，提交自己的用户名和密码进行身份认证，身份认证通过之后服务器端就会给客户端下发一个cookie信息，Cooke交给客户端后，后续的每次访问请求都会携带cookie信息，服务器端之所以能够跟踪</p><p>\1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。<br>\2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。<br>\3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p><ul><li>Session是<strong>在服务端</strong>保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li><li>Cookie是<strong>客户端</strong>保存用户信息的一种机制，用来记录用户的一些信息，<strong>也是实现Session的一种方式</strong>。</li></ul><p>session</p><ul><li>cookie里也可以存放sessionid，真正的session在服务器端，session定时失效</li></ul><p><strong>TLS/SSL</strong></p><ul><li>SSL安全套接层</li></ul><p><strong>身份认证</strong></p><ul><li>证明你是你声称你是的那个人<ul><li>你知道什么–账号密码、PIN、parsparse</li><li>你有什么</li></ul></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;开源&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;黑客&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;骇客&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;白帽子&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命令执行漏洞</title>
    <link href="https://jianier.github.io/2021/03/24/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://jianier.github.io/2021/03/24/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-03-24T13:13:44.000Z</published>
    <updated>2021-04-01T01:13:32.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><p><img src="C:\Users\Administrator\Desktop\360截图20210324195326124.jpg"></p><h3 id="什么是命令执行？"><a href="#什么是命令执行？" class="headerlink" title="什么是命令执行？"></a>什么是命令执行？</h3><p><strong>命令定义</strong>：计算机专业术语，形容在计算机程序编程时所下达的编程指令。</p><p><strong>命令的特点</strong>：</p><ol><li>已经编译好的一串内容</li><li>计算机可以懂的一个指令</li><li>计算机可以执行的一个指令</li></ol><p><strong>Windows常见命令：</strong></p><p>NET命令是Windows中的一个功能强大的工具。虽然必须用命令行方式执行，但他的功能确实覆盖率Windows大部分重要的管理功能。例如，它可以管理网络环境、各种服务程序的运行和配置、进行用户和登录管理等。它还可以查看服务器的许多本地信息。</p><table><thead><tr><th>重要命令</th><th>作用</th></tr></thead><tbody><tr><td>Net user</td><td>添加用户名shiyan，密码123456的用户：Net user shiyan 123456/add  Net user shiyan /del删除用户shiyan  将用户shiyan添加到本地管理员组：Net localgroup administrators shiyan /add</td></tr><tr><td>net view ip</td><td>查看对方局域网开启了哪些共享</td></tr><tr><td>net share</td><td>查看本地开启的共享</td></tr><tr><td>net group</td><td>获得所有域用户组列表</td></tr><tr><td>net user</td><td>获得所有域用户列表</td></tr></tbody></table><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ping</td><td>检测到达某一个网络的连通性</td></tr><tr><td>ipconfig</td><td>查看IP与网络配置</td></tr><tr><td>netstat</td><td>查看端口</td></tr><tr><td>dir</td><td>查看目录</td></tr><tr><td>systeminfo</td><td>查看计算机细腻些(版本、位数、补丁情况)</td></tr></tbody></table><h2 id="Linux常见命令"><a href="#Linux常见命令" class="headerlink" title="Linux常见命令"></a>Linux常见命令</h2><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ls</td><td>查看目录</td></tr><tr><td>cat</td><td>查看文件内容cat /etc/passwd       cat /etc/group     cat /etc/shadow</td></tr><tr><td>su</td><td>切换用户</td></tr><tr><td>crontab</td><td>定时任务命令</td></tr><tr><td>whoami</td><td>查看当前登录用户</td></tr><tr><td>echo</td><td>写入木马echo  ‘&lt;?php@eval($_POST[“x”]);?’&gt;shell.php</td></tr></tbody></table><table><thead><tr><th>应急命令</th><th>作用</th></tr></thead><tbody><tr><td>history</td><td>查看输入过的历史命令</td></tr><tr><td>netstat</td><td>查看开发的端口</td></tr><tr><td>ps</td><td>查看当进程</td></tr><tr><td>grep</td><td>grep “Failed password for root”  /var/log/secure  //过滤</td></tr><tr><td>find</td><td>3天内改动过的文件  find  /路径  -mtime -3  -type f -print</td></tr><tr><td>last</td><td>成功登录、关机、重启</td></tr><tr><td>lastb</td><td>登录失败</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;C:\Users\Administrator\Desktop\360截图2021032419532612</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xss漏洞</title>
    <link href="https://jianier.github.io/2021/03/24/xss%E6%BC%8F%E6%B4%9E/"/>
    <id>https://jianier.github.io/2021/03/24/xss%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-03-24T13:12:09.000Z</published>
    <updated>2021-03-24T13:12:23.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>简介</p><p><strong>XSS作为OWASP TOP10之</strong>一，中文叫做<strong>跨站脚本攻击</strong>Cross-site scripting,本来应该缩写为CSS，但由于和CSS【Cascading Style Sheets,层叠样式脚本】重名，所以更名为XSS。XSS跨站脚本攻击主要基于JavaScript简称JS来完成恶意的攻击行为。</p><p>XSS是一种经常出现在web应用中的计算机安全漏洞，也是web中最主流的攻击方式。</p><p><strong>概念</strong></p><ul><li>XSS是指恶意攻击者利用网站<strong>没有对用户提交数据进行转义处理或者过滤不足</strong>的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。</li><li>从而获取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</li></ul><p><strong>XSS原理</strong></p><p>利用我们所知道的各种黑魔法，向web页面插入JS代码，让JS代码可以被浏览器执行，访问该页面的用户则被攻击</p><p><strong>针对用户</strong></p><ul><li>窃取cookie劫持会话</li><li>网络钓鱼</li><li>放马挖矿</li><li>广告刷流量</li></ul><p><strong>针对WEB服务</strong></p><ul><li>篡改页面</li><li><strong>劫持后台</strong></li><li>传播蠕虫</li><li><strong>内网扫描</strong></li></ul><p>攻击者的JS水平决定了攻击效果</p><h3 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h3><ul><li><p><strong>反射型</strong></p><p>反射型也称作非持久型，这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中</p></li><li><p><strong>存储型</strong></p><p>攻击者将已经构造完成的恶意页面发送给用户，用户访问看似正常的页面后收到攻击，这类XSS通常无法直接在URL中看到恶意代码，具有较强的持久性和隐蔽性</p></li><li><p><strong>DOM型</strong></p><p>DOM型XSS<strong>无需和后端交互</strong>，而是基于JavaScript上，JS解析        URL中恶意参数导致执行JS代码。</p></li></ul><p><strong>存储型的XSS危害是最大的</strong></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><ul><li><p>持久性，代码是存储在web服务器中的，比如在个人信息或发表文章等地方插入代码，如果没有过滤或过滤不严，那么这些代码将存储在服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫】盗窃cookie。每一个访问特定页面的用户，都会受到攻击。</p></li><li><p>特点：</p><ul><li><p>XSS攻击代码存储在web server上</p></li><li><p>攻击者，一般是通过网站的留言、评论、博客、日志等等功能（所有能够向web server输入内容的地方）将攻击代码存储在web server上的<br><img src="https://img-blog.csdnimg.cn/20210322183454829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><ul><li>发射型跨站脚本也称作非持久型、参数型跨站脚本、这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中</li><li>例如</li><li><a href="http://www.test.com/search.php?key=&#39;&#39;&gt;">http://www.test.com/search.php?key=&#39;&#39;&gt;</a>&lt; script&gt;  alert(‘’xss’’) </script></li><li>一般使用的将构造好的URL发给受害者，是受害者点击触发，而且只执行一次，非持久化。<br><img src="https://img-blog.csdnimg.cn/20210322183424120.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><h3 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h3><p>JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。他的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML(标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。</p><h3 id="XSS防御与发现"><a href="#XSS防御与发现" class="headerlink" title="XSS防御与发现"></a>XSS防御与发现</h3><ul><li><p>HTML节点内容的XSS防御</p><p>转义掉&lt;&lt;和&gt;&gt;即转移掉&lt;&gt;即可，转义的时机有两种，一种是写入数据库的时候进行转义，另一种是在解析的时候进行转义</p><p>这里是在显示的时候转义</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtml=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>HTML属性的XSS防御</p><p>转义”&amp;quto”；即转义掉双引号，‘转移掉单引号，另一个要注意的是实际上html的属性可以不包括引号，因此严格的说我们还需要对空格进行转义，但是这样会导致渲染的时候空格数不对，因此我们不转义空格，然后再写html属性的时候全部带上引号）这样属性就不会被提前关闭了</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">str =str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;&amp;quto;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&#x27;/g</span>,<span class="string">&#x27;&amp;#39;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/ /g</span>,<span class="string">&#x27;&amp;#32;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure><p>其实以上这两个函数可以合并成一个函数，这样不管是内容还是属性都可以使用一个函数来过滤了</p><h5 id="html转义函数"><a href="#html转义函数" class="headerlink" title="html转义函数"></a>html转义函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">str =str.replace(<span class="regexp">/&amp;/g</span>,<span class="string">&#x27;&amp;amp;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;&amp;quto;&#x27;</span>);</span><br><span class="line">str =str.replace(<span class="regexp">/&#x27;/g</span>,<span class="string">&#x27;&amp;#39;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure></li><li><p>js转义</p><p>转义“\”  或者替换成json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeForJS=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">str=str.replace(<span class="regexp">/\\/g</span>,<span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">str=str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的解决方式并不完整，因为还有可能是单引号或者其他形式包裹的，这里最保险的方法其实很简单，就是对数据做一次JSON，stringify即可</p></li><li><p>富文本</p><p>由于需要完整的HTML因此不太容易过滤，一般是按照白名单进行保留部分标签和属性来进行过滤，除了允许的标签和属性，其他的全部不允许（也有黑名单的方式，但是由于html复杂效果比较差，原理就是之前的正则替换）</p><p>其实可以用别人写好的XSS组件就叫做XSS，直接</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> xss</span><br></pre></td></tr></table></figure><p>白名单—-使用第三方库XSS，支持指定白名单</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xssFilter=function(html)&#123;</span><br><span class="line">if(!html) return &#x27;&#x27;;</span><br><span class="line">var xss=require(&#x27;xss&#x27;);</span><br><span class="line">var ret=xss.(html,&#123;</span><br><span class="line">whiteList;&#123;</span><br><span class="line">img;[&#x27;src&#x27;],</span><br><span class="line">a;[&#x27;href&#x27;].</span><br><span class="line">font;[&#x27;size&#x27;,&#x27;color&#x27;]</span><br><span class="line">&#125;,</span><br><span class="line">        onIgnoreTag;function()&#123;</span><br><span class="line">        return &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(html,ret);</span><br></pre></td></tr></table></figure><h3 id="Pikachu靶场上的漏洞类型列表如下："><a href="#Pikachu靶场上的漏洞类型列表如下：" class="headerlink" title="Pikachu靶场上的漏洞类型列表如下："></a>Pikachu靶场上的漏洞类型列表如下：</h3><ul><li><p>Burt Force（暴力破解漏洞）</p></li><li><p>XSS（跨站脚本漏洞）</p></li><li><p>CSRF（跨站请求伪造）</p></li><li><p>SQL-Inject（SQL注入漏洞）</p></li><li><p>RCE（远程命令/代码执行）</p></li><li><p>Files Inclusion（文件包含漏洞）</p></li><li><p>Unsafe file downloads（不安全的文件下载）</p></li><li><p>Unsafe file uploads（不安全的文件上传）</p></li><li><p>Over Permisson（越权漏洞）</p></li><li><p>../../../（目录遍历）</p></li><li><p>I can see your ABC（敏感信息泄露）</p></li><li><p>PHP反序列化漏洞</p></li><li><p>XXE(XML External Entity attack)</p></li><li><p>不安全的URL重定向</p></li><li><p>SSRF（Server-Side Request Forgery）</p></li></ul></li></ul><h3 id="XSS蠕虫攻击"><a href="#XSS蠕虫攻击" class="headerlink" title="XSS蠕虫攻击"></a>XSS蠕虫攻击</h3><p>XSS蠕虫的破坏力和影响力都是巨大的。XSS蠕虫主要发生在用户之间存在交互行为的页面中，当web应用程序对用户输入的数据信息没有严格的过滤时，通过结合Ajax的异步提交，就可以实现在植入恶意代码的同时，将恶意代码进行对外发送，即实现了代码的感染和传播，也就形成了XSS蠕虫。</p><h3 id="挖掘XSS漏洞方法"><a href="#挖掘XSS漏洞方法" class="headerlink" title="挖掘XSS漏洞方法"></a>挖掘XSS漏洞方法</h3><ul><li><p><strong>扫描工具自动化检测</strong></p><p><strong>WVS</strong></p><p><strong>AppScan</strong></p><p><strong>JSky</strong></p></li><li><p><strong>手工测试</strong></p></li><li><p><strong>源码分析</strong></p></li></ul><h3 id="XSS跨站脚本攻击漏洞防范"><a href="#XSS跨站脚本攻击漏洞防范" class="headerlink" title="XSS跨站脚本攻击漏洞防范"></a>XSS跨站脚本攻击漏洞防范</h3><ul><li><strong>客户端用户</strong><ul><li>IE8及高版本，开启XSS筛选器功能</li><li>Firefox使用CSP、Noscript等扩展功能</li><li>瑞星个人防火墙2012版本开启XSS拦截功能</li></ul></li><li><strong>WEB应用程序员</strong><ul><li>使用HttpOnly</li><li>完整的输入、检出检查</li></ul></li></ul><p><strong>HttpOnly</strong></p><ul><li><p><strong>HttpOnly</strong>最初是由微软提出的，目前已经被多款流行浏览器厂商所采用。<strong>HttpOnly</strong>的作用不是过滤XSS跨站脚本攻击，而是浏览器将禁止页面的JavaScript访问带有<strong>HttpOnly</strong>属性的cookie,解决XSS跨站脚本攻击后的Cookie会话劫持行为</p></li><li><p><strong>HttpOnly</strong>是在Set-Cookie时进行标记的，设置的Cookie头格式如下：<br><img src="https://img-blog.csdnimg.cn/20210322183336920.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>以php为例，在php 5.2版本时就已经在SetCookie函数加入了对HttpOnly的支持，如：</p><?php        setcookie("user","admin",NULL,NULL,NULL,NULL,TRUE);?><p>通过以上代码就可以设置user这个cookie，将其设置为HttpOnly,setcookie函数实质是通过向客户端发送原始的HTTP报文头进行设置的，document将不可见这个Cookie，所以使用document.cookie就取不到这个cookie，也就实现了对cookie的保护。</p></li><li><p><strong>输入、输出检查</strong></p><p>由于三种XSS跨站脚本攻击类型的漏洞成因可不相同，针对输入输出的检查一部分适用于反射型XSS与存储型XSS，而另外一些检查适用于基于DOM 的XSS</p><ul><li><p><strong>反射型和存储型XSS输入、输出检查</strong></p><ul><li><p><strong>输入检查</strong></p><p>在大多数的时候都是对可信字符的检查或输入数据格式的检查，如用户输入的注册账号信息中只允许包括字母、数字、下划线和汉字等，对于输入的<strong>一切非白名单</strong>的字符均认为是非法输入。数据格式如输入的IP地址、电话号码、邮件地址、日期等数据都具有一定的格式规范，只有符合数据规范的输入信息才允许通过检查</p><ul><li><p><strong>输出检查</strong></p><p>输出检查主要是针对数据展示过程中，应该对数据信息进行HTML<strong>编码</strong>处理，将可能存在导致XSS跨站脚本攻击的恶意字符进行编码，在不影响正常数据显示的前提条件下，<strong>过滤恶意字符</strong></p></li><li><p>常见的可能造成XSS跨站脚本攻击的字符及其HTML编码如下——<strong>输出检查</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;    <span class="symbol">&amp;quot;</span></span><br><span class="line">&#x27;    <span class="symbol">&amp;apos;</span></span><br><span class="line">&amp;    <span class="symbol">&amp;amp;</span></span><br><span class="line">&lt;    <span class="symbol">&amp;lt;</span></span><br><span class="line">&gt;    <span class="symbol">&amp;gt;</span></span><br><span class="line">    除了常用的编码外，任何字符都可以使用其ASCLL码进行HTML编码，如</span><br><span class="line">    %    <span class="symbol">&amp;#37;</span></span><br><span class="line">    *    <span class="symbol">&amp;#42;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><ul><li><p><strong>DOM Based XSS 输入、输出检查</strong></p><ul><li><p><strong>特殊性</strong></p><p>基于DOM的XSS跨站脚本攻击发生时，恶意数据的格式与传统的XSS跨站脚本攻击数据格式有一定的差异，甚至可以在<strong>不经过服务器的处理和响应</strong>的情况下，直接对客户端实施攻击行为。</p></li><li><p><strong>输入检查</strong></p><p>在<strong>客户端</strong>部署相应的安全检测代码的过滤效果要比在服务器检测的效果更加明显</p><p>客户端检测代码来保证用户输入的数据只包含字母、数字和空格</p><p>在<strong>服务端</strong>实现上述数据检查的功能</p><ul><li>URL参数名称、个数检测</li><li>参数值类型及内容检测</li></ul></li><li><p><strong>输出检查</strong></p><ul><li>在将用户可控的DOM数据内容插入到文档之前，WEB应用程序应对提交的数据进行HTML编码处理，将用户提交的数据中可能存在的各种危险字符和表达式进行过滤以安全的方式插入到文档进行展示。</li></ul></li></ul><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><ul><li><p><strong>网站安全狗</strong></p></li><li><p><strong>XSSer</strong></p><p>XSSer简称Cross site ‘scripter’是一款自动化渗透测试XSS漏洞的安全工具，专门用来<strong>检测和利用</strong>不同应用程序中存在的跨站脚本漏洞。它包含了一些选项用来尝试绕过特定的过滤器，并且具有特殊的代码注入技术。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h2&gt;&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XSS作为OWASP TOP10之&lt;/strong&gt;一，中文叫做&lt;strong&gt;跨站脚本攻击&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="https://jianier.github.io/2021/03/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>https://jianier.github.io/2021/03/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-03-24T13:10:49.000Z</published>
    <updated>2021-03-24T13:11:13.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><strong>什么是文件上传？</strong></p><p>​    上传漏洞这个顾名思义，就是攻击者通过上传木马文件，直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。</p><p>​    导致该漏洞的原因在于代码作者<strong>没有对访客提交的数据进行检验或者过滤不严</strong>，可以直接提交修改过的数据绕过<strong>扩展名的检验</strong>。</p><p><strong>什么是webshell?</strong></p><p>​    webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称作为一种网页后门。黑客在入侵一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得<strong>到一个命令执行环境，以达到控制网站服务器的目的。</strong></p><p>顾名思义，“web”的含义是显然需要服务器开放web服务，<strong>“shell”的含义是取得对服务器某种程度上操作权限</strong>。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以<strong>动态脚本</strong>的形式出现，也有人称之为<strong>网站的后门工具。</strong></p><p><strong>什么是中间件？</strong></p><p>​    中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯。<strong>是连接两个独立应用程序或独立系统的软件</strong>。相连接的系统，即使他们具有不同的接口，但通过中间件相互之间仍能交互信息。</p><p>执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p><p>中间件是<strong>介于操作系统和应用软件之间</strong>，为应用软件提供服务功能的软件，有消息中间件、交易中间件、应用服务器等。由于介于两种软件之间，称为中间件。</p><p><strong>为什么使用中间件？</strong></p><p>具体地说，中间件<strong>屏蔽了底层操作系统的复杂性</strong>，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，<strong>将注意力集中在自己的业务上</strong>，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><p><strong>常见中间件：Apache、Nginx、Tomcat、Weblogic等</strong></p><h3 id="文件上传分类"><a href="#文件上传分类" class="headerlink" title="文件上传分类"></a>文件上传分类</h3><ul><li><p><strong>客户端JS绕过(前端)</strong></p></li><li><p><strong>服务器端漏洞(后端)</strong></p><p><img src="C:\Users\Administrator\Desktop\360截图20210322195235414.jpg"></p></li></ul><p><strong>举例：</strong></p><h4 id="0x01-客户端验证绕过-javascript-扩展名检测-——js绕过"><a href="#0x01-客户端验证绕过-javascript-扩展名检测-——js绕过" class="headerlink" title="0x01   客户端验证绕过(javascript 扩展名检测)——js绕过"></a>0x01   客户端验证绕过(javascript 扩展名检测)——<strong>js绕过</strong></h4><p>打开http反向代理工具  burp</p><p>先随便点击上传一个2012.asa</p><p>然后还没点击Upload</p><p>burp里也还没出现任何内容</p><p>便弹出一个警告框‘</p><p>一看就知道是个客户端验证JavaScript</p><p>只需要把他禁掉或者通过burp进行代理修改  可以在火狐按住F12可以在js那行把我们想要的那个添加或者删除掉就可以  </p><p>这里我用burp进行代理修改</p><p>先将文件扩展名改成.jpg</p><p>然后Upload</p><p>现在的文件名是2012.jpg</p><p>在burp里将jpg改成.asp</p><p>然后继续上传</p><p>最后可以看到asp成功上传</p><h4 id="0x02-服务端验证绕过-http-request包检测"><a href="#0x02-服务端验证绕过-http-request包检测" class="headerlink" title="0x02  服务端验证绕过(http request包检测)"></a>0x02  服务端验证绕过(http request包检测)</h4><p>-Content-type(Mime-type)  检测</p><p>假如服务器端代码如下</p><p><img src="C:\Users\Administrator\Desktop\360截图20210322200148498.jpg"></p><p><img src="C:\Users\Administrator\Desktop\2.jpg"></p><h4 id="服务器验证绕过（扩展名检测）"><a href="#服务器验证绕过（扩展名检测）" class="headerlink" title="服务器验证绕过（扩展名检测）"></a>服务器验证绕过（扩展名检测）</h4><p>黑名单检测</p><p>黑名单的安全性其实还没白名单的安全性高，至少攻击他的方式比白名单多多了</p><p>一般有个专门的blacklist文件，里面会包含常见的危险脚本文件</p><p>例如 fckeditor 2.4.3或之前版本的黑名单</p><p><img src="C:\Users\Administrator\Desktop\5.jpg"></p><h4 id="0x00截断绕过-—这个是基于一个组合逻辑漏洞造成的"><a href="#0x00截断绕过-—这个是基于一个组合逻辑漏洞造成的" class="headerlink" title="0x00截断绕过  —这个是基于一个组合逻辑漏洞造成的"></a>0x00截断绕过  —这个是基于一个组合逻辑漏洞造成的</h4><p>给个简单的伪代码</p><p>name=getname(http request)  //假如这时候获取到的文件名是help.asp .jpg（asp后面为0x00)  type=gettype(name)  //而在<strong>gettype()函数里处理方式是从后往前扫描扩展名，</strong>所以判断为jpg</p><p>if(type==jpg)</p><p>​    SaveFileToPath(UploadPath.name,name)  //但在这里却是以0x00作为文件名截断</p><p>//最后以help.asp存入路径里</p><h4 id="双扩展名解析绕过攻击-1-—基于web服务的解析逻辑"><a href="#双扩展名解析绕过攻击-1-—基于web服务的解析逻辑" class="headerlink" title="双扩展名解析绕过攻击(1)—基于web服务的解析逻辑"></a>双扩展名解析绕过攻击(1)—基于web服务的解析逻辑</h4><p>如果上传一个文件名为help.asp.123</p><p>首先扩展名123并没有在扩展名blacklist里，然后扩展名123也没在apache可解析扩展名list里，这个时候它会向前搜索下一个可解析扩展名，或搜寻到  .php，最后会以php执行</p><h4 id="双扩展名解析绕过攻击-1-—基于web服务的解析方式"><a href="#双扩展名解析绕过攻击-1-—基于web服务的解析方式" class="headerlink" title="双扩展名解析绕过攻击(1)—基于web服务的解析方式"></a>双扩展名解析绕过攻击(1)—基于web服务的解析方式</h4><p>如果在apache的conf里有这样一行配置</p><p>AddHandler php5-script.php</p><p>这时只要文件名里包含.php</p><p>即使文件名是test2.php.jpg也会以php来执行</p><h4 id="危险解析绕过攻击—基于web服务的解析方式"><a href="#危险解析绕过攻击—基于web服务的解析方式" class="headerlink" title="危险解析绕过攻击—基于web服务的解析方式"></a>危险解析绕过攻击—基于web服务的解析方式</h4><p>如果在apache的conf里有这样一行配置</p><p>AddType applications-httpd-php.jpg</p><p>即使扩展名是.jpg，一样能以php方式执行</p><h3 id="白名单检测"><a href="#白名单检测" class="headerlink" title="白名单检测"></a>白名单检测</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p><ol><li><p>特别文件名构造(同黑名单攻击第三条)</p></li><li><p>IIS或nginx文件名解析漏洞(同黑名单攻击第四条)</p></li><li><p>0x00截断绕过(同黑名单攻击第五条)</p><p>.htaccess文件攻击</p></li></ol><p>无论是黑名单还是白名单</p><p>再直接点就是直接攻击.htaccess文件</p><p>在PHP  manual中提到了下面一段话</p><p>move_uploaded_file section,ther is a warning which states</p><p>‘if the destination file already exists,it will be overwritten.’</p><p>如果PHP安全没配置好</p><p>就可以通过move_uploaded_file函数把自己写的.htaccess文件覆盖掉服务上的</p><p>这样就能任意定义解析名单了</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>客户端验证绕过(javascript扩展名检测)</p><p>用反向代理工具(burp之类)或禁用js便可以绕过客户端验证</p></li><li><p>服务端验证绕过(http request包检测)</p><p>-Content-type(Mime type)检测</p><p>用反向代理工具(burp之类的)进行Content-type伪造</p></li><li><p>服务端验证绕过(扩展名检测)</p><p>-<strong>黑名单检测</strong></p><p>找黑名单扩展名的漏网之鱼–比如上面就漏掉了asa和cer之类</p><p>可能存在大小写绕过漏洞–比如aSp和pHp之类</p><p>特别文件名构造–比如发送的http包里把文件名改成help.asp或 help.asp_（下划线为空格)</p><p>IIS或nginx文件名解析漏洞—比如help.asp;.jpg或<a href="http://www.xx.com/help.jpg/2.php">http://www.xx.com/help.jpg/2.php</a></p><p>0x00截断绕过–这个是基于一个组合逻辑漏洞造成的</p><p>双扩展名解析绕过攻击(1)–基于web服务的解析逻辑</p><p>双扩展名解析绕过攻击(2)–基于web服务的解析方式</p><p>危险解析绕过攻击–基于web服务的解析方式</p><p>–<strong>白名单检测</strong></p><p>特别文件名构造(同黑名单攻击第3条)</p><p>IIS或nginx文件名解析漏洞(同黑名单攻击第4条)</p><p>0x00截断绕过(同黑名单攻击第5条)</p><p>-<strong>.htaccess文件名攻击</strong></p><p>在PHP安全没配置好的情况下，用自己的.htaccess覆盖服务上原文件</p></li><li><p>服务端验证绕过(文件完整性检测)</p><p>-<strong>文件头检测</strong></p><p>在文件开始伪装文件的幻数</p><p>-<strong>图像分辨率检测</strong></p><p>在文件开始伪装图像大小数据</p><p>-<strong>文件加载检测</strong></p><p>用工具对文件空白数据区或注释区进行代码注入绕过</p><p>(图像仅能绕过渲染测试，而不能绕过二次渲染)</p><p>用恶意文件去攻击加载器本身</p></li><li><p>相互关系与组合情况</p><p>首先客户端验证和服务端验证是相互独立的，所以分开绕过就行了</p><p>主要难点是在服务端验证的组合上</p><p>文件完整性检测已经包含文件头检测和图像大小及相关信息检测，但不包含文件扩展名检测</p><p>它是以加载来作为检测的方式，比如用图像渲染函数去渲染一张图片</p><p>文件扩展名检测和文件头都是同级的，相互独立</p><p>所以如果是文件扩展名+文件头检测可以同时分开绕过</p><p>-<strong>IIS文件名，解析漏洞</strong></p><p>漏洞描述</p><p>当文件名为[YYY].asp；[ZZZ].jpg时，Microsoft IIS会自动以asp格式来进行解析。</p><p>而当文件名为[YYY].php；[ZZZ].jpg时，Microsoft IIS会自动以php格式来进行解析。</p><p>其中[YYY]与[ZZZ]处可为变化字符串</p><p>影响平台：</p><ol><li><p>等待微软相关的补丁包</p></li><li><p>关闭图片所在目录的脚本执行权限(前提是你的某些图片没有与程序混合存放)</p></li><li><p>校验网站程序中所有上传图片的代码段，对形如[YYY].asp；[ZZZ].jpg的图片做拦截</p><p>备注:</p><p>对于Windows server 2008(IIS7)以及Windows server 2008 R2(IIS7.5)则未受影响</p><p><strong>文件类型解析。IIS6.0默认的可执行文件处了.asp，还包括.asa、.cdx、.cer</strong></p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什么是文件上传？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    上传漏洞这个顾名思义，就是攻击者通过上传木马文件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sql注入</title>
    <link href="https://jianier.github.io/2021/03/24/sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://jianier.github.io/2021/03/24/sql%E6%B3%A8%E5%85%A5/</id>
    <published>2021-03-24T13:06:28.000Z</published>
    <updated>2021-03-24T13:12:35.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><pre><code>SQL注入攻击就是攻击者把SQL命令插入到web表单的输入域（比如登录页面或查询框）与或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。</code></pre><p>比如select * from user where id=1**‘ or 1=’**1 ——万能密码<br><img src="https://img-blog.csdnimg.cn/2021032218370159.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="SQL注入万能密码"><a href="#SQL注入万能密码" class="headerlink" title="SQL注入万能密码"></a>SQL注入万能密码</h4><p><img src="https://img-blog.csdnimg.cn/20210322183719172.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>查询数据库分类</strong></p><ul><li><strong>数字型注入</strong>（select * from users where id=  <strong>x</strong>)</li><li><strong>字符型注入</strong>    (select * from users where id =  <strong>‘x’</strong>)</li><li><strong>搜索型注入</strong>    (select * from database.table where users like ‘<strong>%要查询的关键字%’</strong>)</li></ul><p><strong>分类</strong></p><p><strong>数据提交方式</strong></p><ul><li>get注入</li><li>post注入</li><li>http头部注入（user-agent、cookie、referer、host)</li></ul><p><strong>其余</strong></p><p>还有一些常见的数据库注入类型；报错注入、盲注、延时注入、宽字节注入、二次注入、堆叠注入等</p><p><strong>SQL注入的危害</strong></p><ol><li>攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露、</li><li>可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账户</li><li>如果网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违规信息等</li><li>经过提权等步骤，服务器最高权限被攻击者获取。攻击者可以远程控制服务器，安装后门，得以修改或控制操作系统。</li></ol><h4 id="自动化注入工具"><a href="#自动化注入工具" class="headerlink" title="自动化注入工具"></a>自动化注入工具</h4><p><strong>Havij</strong></p><p>是一款自动化的SQL注入工具，它能够帮助渗透测试人员发现和利用web应用程序的SQL注入漏洞。Havij不仅能够自动挖掘可利用的 SQL查询，还能够识别后台数据库类型、检索数据的用户名和密码hash、转储表和列、从数据库中提取数据，甚至访问底层文件系统和执行系统命令，当然前提是有一个可利用的SQL注入漏洞。Havij支持广泛的数据库系统，如MsSQL，Mysql，MSAccess and Oracle。Havij支持参数配置以躲避IDS，支持代理，后台登录地址扫描。</p><p><strong>Sqlmap</strong></p><p>是一个自动SQL注入工具其可胜任执行一个广泛数据库管理系统后端指纹，检索DBMS数据库，usernames、表格、列、并列举整个DBMS信息。sqlmap提供转储数据库表以及Mysql、PostgreSQL、SQL Server服务器下载或上传任何文件并执行任意代码的能力</p><p><strong>The Mole</strong></p><p>是一款开源的 自动化SQL注入工具，其可绕过IPS/IDS(入侵防御系统/入侵检测系统)/只需提供一个URL和一个可用的关键字，他就能检测诸如点并利用。The Mole可以使用union注入技术和基于逻辑查询的注入技术。The Mole攻击范围包括SQL Server、MySQL、Postgres和Oracle数据库。</p><h3 id="手动注入的过程"><a href="#手动注入的过程" class="headerlink" title="手动注入的过程"></a>手动注入的过程</h3><ul><li>判断是否存在注入点 and 1=1和and 1=2或者单引号</li><li>判断字段长度 通过order by 长度一般是5开始</li><li>判断字段回显位置 使用union select  1,2,3,4字段长度</li><li>拿数据（库表字段数据）比如version() 、database()、table_name    table_schema</li></ul><p>group_concat(table_name,password)</p><h3 id="手工暴错注入"><a href="#手工暴错注入" class="headerlink" title="手工暴错注入"></a>手工暴错注入</h3><p>updatexml(1,concat(0x7e </p><h3 id="盲注-就是不断尝试、猜想"><a href="#盲注-就是不断尝试、猜想" class="headerlink" title="盲注(就是不断尝试、猜想)"></a>盲注(就是不断尝试、猜想)</h3><p><strong>盲注函数</strong></p><p><strong>MID(column_name,start[,length])</strong></p><p><strong>string substr(string,start,length)</strong></p><p><strong>Left(string,n)</strong></p><p>比如 id=1’ and left(version(),1)=5–+</p><h3 id="攻击特征"><a href="#攻击特征" class="headerlink" title="攻击特征"></a>攻击特征</h3><h4 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h4><ul><li><p><strong>#</strong></p></li><li><p><strong>–</strong></p></li><li><p><strong>/</strong>/**</p></li><li><p><strong>#</strong></p></li><li><p><strong>–+</strong></p></li></ul><p>防护工具——<strong>安全狗</strong></p><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li><p>严格限制web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。</p></li><li><p>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型</p></li><li><p>对进入数据库的特殊字符(“  ‘  \ 尖括号 &amp; *；等   “)进入转义处理，或编码转换</p><p>text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理。</p></li><li><p>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，既不要直接拼接SQL语句</p></li><li><p>在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap等</p></li><li><p>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入</p><h3 id="注入工具介绍"><a href="#注入工具介绍" class="headerlink" title="注入工具介绍"></a>注入工具介绍</h3><p><strong>sqlmap</strong></p></li></ul><p>sqlmap是一个开源的渗透工具，它可以自动化检测和利用SQL注入缺陷以及接管数据库服务器的过程。他有一个强大的检测引擎，许多适合于终极渗透测试的小众特性和广泛的开关，从数据库指纹、从数据库获取数据到访问底层文件系统和通过带外连接在操作系统上执行命令。</p><h3 id="SQL注入的参数"><a href="#SQL注入的参数" class="headerlink" title="SQL注入的参数"></a>SQL注入的参数</h3><ul><li><p>-u  #注入点</p></li><li><p>-g  谷歌搜索</p></li><li><p>-f  #指纹判别数据库版本信息</p></li><li><p>-p  #指定可测试的参数(?page=1 &amp; id=2 -p “page,id”)</p></li><li><p>-D “ ” #指定数据库名</p></li><li><p>-T  “ “#指定表名</p></li><li><p>-C   “ ” #指定字段</p></li><li><p>-s   “ ”  #保存注入过程到一个文件，还可中断，下次恢复在注入（保存：-s”xx.log”    恢复：-s “xx.log” -resume)</p></li><li><p>-columns  #列出字段</p></li><li><p>-current -user   #获取当前用户名称</p></li><li><p>-current -db      #获取当前数据库名称</p></li><li><p>-users  # 列数据库所有用户</p></li><li><p>-passwords  #数据库用户所有密码</p></li><li><p>-privileges  #查看用户权限(-privileges -U root)</p></li><li><p>-U  #指定数据库用户</p></li><li><p>-dbs  #列出所有数据库</p></li><li><p>-tables -D  “ “ #列出指定数据库中的表</p></li><li><p>-columns -T “user” -D  “mysql”  #列出mysql数据库中的user表中的所有字段</p></li><li><p>-dump-all  #列出所有数据库所有表</p></li><li><p>-exclude -sysdbs  #只列出用户自己新建的数据库和表</p></li><li><p>-dump -T “ “ -D “ “ -C  ” “  #列出指定数据库的表的字段的数据(-dump -T users -D master -C surname)</p></li><li><p>-dump -T “” -D -start 2 -top 4  #列出指定数据库的表的2-4字段的数据</p><ul><li>-dbms #指定数据库(MySQL，Oracle，PostgreSQL,Microsoft SQL，Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)</li></ul></li><li><p>-os  #指定系统（Linux，Windows）</p></li><li><p>–sql -shell 写shell</p></li><li><p>–delay 延迟时间</p></li><li><p>-m  可以执行多个url</p></li><li><p>–level 3 –risk 5等级</p></li><li><p>sqlmap -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -f -b -current -user</p></li><li><p>-currernt-db -v 1</p></li><li><p>sqlmap -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -dbs -v 2</p></li><li><p>sqlmap  -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -dump -D mysql -T</p></li><li><p>users -C ‘’username,password’ -s ‘’sqlnmapdb.log’’ -v 2</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;SQL注入攻击就是攻击者把SQL命令插入到web表单的输入域（比如登录页面或查询框）与或页面请求的查</summary>
      
    
    
    
    <category term="sql注入" scheme="https://jianier.github.io/categories/sql%E6%B3%A8%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://jianier.github.io/2021/02/05/Dubbo/"/>
    <id>https://jianier.github.io/2021/02/05/Dubbo/</id>
    <published>2021-02-05T09:14:06.000Z</published>
    <updated>2021-02-05T09:36:08.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-分布式理论基础"><a href="#1-分布式理论基础" class="headerlink" title="1. 分布式理论基础"></a>1. 分布式理论基础</h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a>1.1 什么是分布式系统？</h3><p>分布式系统(distributed system)是建立在网络之上的软件系统。</p><p>随着互连网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需    一个<strong>治理系统</strong>（比如说Dubbo）确保架构有条不紊的演进。</p><h3 id="1-2-发展演变"><a href="#1-2-发展演变" class="headerlink" title="1.2 发展演变"></a>1.2 发展演变</h3><p><img src="https://img-blog.csdnimg.cn/20210205104436391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p><strong>单一应用架构</strong> 比如：超市的收银系统、公司的管理系统、小型的网站应用</p><ul><li><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</p></li><li><p>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210205104557417.png#pic_center" alt="在这里插入图片描述"></p><p><strong>缺点</strong>：</p><p>扩展应用(带着整个应用扩展)不容易、协调开发不容易(同时在一个上去开发)</p></li><li><p><strong>垂直应用架构</strong></p><ul><li><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</p></li><li><p>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p><p><img src="https://img-blog.csdnimg.cn/20210205104459438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>每一个模块从页面、业务逻辑、程序、数据库都是完整的</p><p><strong>优点</strong>：开发和维护不同的应用互不干扰、性能扩展容易、</p><p><strong>缺点</strong>：</p><ol><li>界面+业务逻辑的实现分离</li><li><strong>应用之间不可能完全独立，大量的应用之间需要交互</strong></li></ol></li></ul></li><li><p><strong>分布式服务架构</strong> </p><ul><li><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p></li><li><p>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p><p><img src="https://img-blog.csdnimg.cn/20210205104517127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>优点</strong>：把核心业务抽取出来，只需要改动界面即可。服务器上的核心业务还在服务器上。</p><p><strong>缺点</strong>：不能实时管理服务器。造成浪费</p><p><strong>分布式服务框架(RPC)：</strong>远程过程调用 </p><p>分布式架构的<strong>难点</strong>就是如何拆分业务+如何远程过程调用</p></li></ul></li><li><p><strong>流动计算架构</strong> </p><ul><li><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</p></li><li><p>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</p><p><img src="https://img-blog.csdnimg.cn/20210205104534489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>负责维护整个服务集群，可以实时的管理集群容量，比如A服务器访问量大了，可以给A动态的多来几台。</p></li></ul></li></ul><h3 id="1-3-RPC"><a href="#1-3-RPC" class="headerlink" title="1.3 RPC"></a>1.3 RPC</h3><p><strong>什么叫RPC？</strong></p><p><strong>RPC【Remote Procedure Call】</strong>是指远程过程调用，是一种进程间的通信方式，它是一种技术思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显示编码这个远程调用的细节。即程序员无论是调用本地还是远程的函数，本质上编写的调用代码基本相同。</p><p><strong>RPC基本原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210205104635464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>通俗说来就是A和B两个服务器建立起一个网络连接，他们之间进行通信。</p><p><img src="https://img-blog.csdnimg.cn/20210205104619296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>影响RPC机制的两个因素就是<strong>①序列化和反序列化机制的速度②能否快速的在各个服务器之间建立连接即通信效率</strong></p><p><strong>RPC的两个核心模块：通信、序列化</strong></p><p><strong>RPC 框架有很多如：</strong></p><p><strong>dubbo、</strong>gRPC、Thrift、HSF(High Speed Service Framework)</p><h1 id="二、Dubbo配置"><a href="#二、Dubbo配置" class="headerlink" title="二、Dubbo配置"></a>二、Dubbo配置</h1><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2. Dubbo核心概念"></a>2. Dubbo核心概念</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>Apache Dubbo</strong>是一款高性能、轻量级的开源Java RPC框架，他提供了三大核心能力：<strong>①面向接口的远程方法调用，②智能容错和负载均衡，以及③服务自动注册和发现。</strong></p><p>官网：<a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></p><p><strong>Dubbo的特性；</strong></p><ul><li><p>面向<strong>接口</strong>代理的高性能RPC调用：为开发者屏蔽远程调用底层细节</p></li><li><p>服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知</p><p><img src="https://img-blog.csdnimg.cn/20210205104655848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><p>  <strong>注册中心</strong>相当于所有服务都在哪个服务器上的一个清单比如支付业务在4 6 9服务器上有安装负载均衡看选择哪个服务器合适</p><ul><li><p>运行期流量调度：内置条件、脚本等路由策略</p></li><li><p>智能负载均衡</p></li><li><p>高度可扩展能力：遵循微内核+插件的设计原则</p></li><li><p>可视化的服务治理与运维</p></li></ul><h3 id="2-2高性能Java-RPC框架——Dubbo设计框架"><a href="#2-2高性能Java-RPC框架——Dubbo设计框架" class="headerlink" title="2.2高性能Java RPC框架——Dubbo设计框架"></a>2.2高性能Java RPC框架——Dubbo设计框架</h3><p><img src="https://img-blog.csdnimg.cn/20210205104713663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p></li><li><p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p></li><li><p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p></li><li><p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p></li></ul><h3 id="2-3-zookeeper注册中心"><a href="#2-3-zookeeper注册中心" class="headerlink" title="2.3 zookeeper注册中心"></a>2.3 zookeeper注册中心</h3><p><strong>Zookeeper</strong>是Apache Hadoop的子项目，是一个树型的目录结构，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p><p><img src="https://img-blog.csdnimg.cn/20210205104734728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-dubbo-helloword实例"><a href="#3-dubbo-helloword实例" class="headerlink" title="3.dubbo-helloword实例"></a>3.dubbo-helloword实例</h2><h3 id="3-1提出需求"><a href="#3-1提出需求" class="headerlink" title="3.1提出需求"></a>3.1提出需求</h3><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p><p>我们现在需要创建两个服务模块进行测试</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>订单服务web模块</td><td>创建订单等</td></tr><tr><td>用户服务service模块</td><td>查询用户地址等</td></tr></tbody></table><p>测试预期结果：</p><pre><code>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</code></pre><p><img src="https://img-blog.csdnimg.cn/20210205104752913.png#pic_center" alt="在这里插入图片描述"></p><p><strong>本地存根</strong></p><p><img src="https://img-blog.csdnimg.cn/20210205165308490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>SpringBoot与dubbo整合的三种方式：</strong></p><p>1）导入dubbo-starter依赖，在application.properties配置属性，使用@Service【暴力服务】和使用@Reference【 引用服务】，同时还要在启动类中开启dubbo注解功能@EnableDubbo</p><p>2）保留dubbo.xml配置文件;</p><p>导入dubbo-start依赖、使用@ImportResource导入dubbo的配置文件即可【在启动类中配置@ImportResource(location=”classpath:provider.xml”)】</p><p>3）使用注解API方式；</p><p>将原先配置文件xml中的每一个组件通过手动创建到容器中，即写一个配置类@Configuration，将每一个组件通过@Bean注入到容器中、在启动类中使用@DubboComponentScan()或者用@EnableDubbo(scanBasePackages=”包名”)  @Service注解暴露出来</p><h1 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h1><h2 id="1、zookeeper宕机与dubbo直连"><a href="#1、zookeeper宕机与dubbo直连" class="headerlink" title="1、zookeeper宕机与dubbo直连"></a>1、zookeeper宕机与dubbo直连</h2><p>zookeeper注册中心宕机，还可以消费dubbo暴漏的服务。</p><p>原因：</p><p>健壮性</p><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍然能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍然能通过本地缓存通讯</strong></li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等服务提供者恢复</li></ul><p>高可用：通过设计，减少系统不能提供服务的时间</p><p><strong>dubbo直连</strong></p><p>直接绕过注册中心与服务相连，是通过@Reference注解中直接设置服务提供者的url</p><h2 id="2、集群下dubbo负载均衡配置"><a href="#2、集群下dubbo负载均衡配置" class="headerlink" title="2、集群下dubbo负载均衡配置"></a>2、集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随即调用</p><p><strong>负载均衡策略：</strong></p><ul><li><p><strong>Random LoadBalance</strong></p><p>随机，按权重设置随机概率。</p><p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p><p><img src="https://img-blog.csdnimg.cn/20210205165330907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><ul><li><p>RoundRobin LoadBalance</p><p>轮询，按公约后 的权重设置轮询比率。</p><p>存在慢的提供者累计请求的问题，比如，第二台机器很慢，但没挂，当请求调到第二台时就卡在那 ，久而久之，所有请求都卡在调到第二台上。</p><p><img src="https://img-blog.csdnimg.cn/20210205165342580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p><strong>LeastActive LoadBalance</strong></p><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p><p>使慢的提供者收到更少的请求，因为越慢的提供者的调用前后计数差会越大。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210205165356499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p><strong>ConsistentHash LoadBalance</strong></p><p>一致性Hash，相同参数的请求总是发到同一提供者</p><p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平衡到其他提供者，不会引起剧烈变动。算法参见:<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p><p>缺省只对第一个参数Hash，如果要修改，请配置&lt;dubbo:parameter key=”hash.arguments” value=”0.1”/&gt;</p><p>缺省用160份虚拟节点，如果要修改，请配置&lt;dubbo:parameter key=”hash.nodes” value=”320”/&gt;</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210205165408957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-整合hystrix，服务容错"><a href="#3-整合hystrix，服务容错" class="headerlink" title="3.整合hystrix，服务容错"></a>3.整合hystrix，服务容错</h2><h3 id="1）什么是服务降级？"><a href="#1）什么是服务降级？" class="headerlink" title="1）什么是服务降级？"></a>1）什么是<strong>服务降级</strong>？</h3><p><strong>当服务器压力剧增的情况下，根据实际业务及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作</strong>。</p><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p><img src="https://img-blog.csdnimg.cn/20210205165421518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2）集群容错"><a href="#2）集群容错" class="headerlink" title="2）集群容错"></a>2）<strong>集群容错</strong></h3><p>在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。</p><p><strong>集群容错模式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20210205165434577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>集群模式配置：</strong></p><p>按照一下示例在服务提供方和消费方配置集群模式</p><p>&lt;dubbo:service cluste”failsafe/&gt;</p><p>或</p><p>&lt;dubbo:reference cluste”failsafe/&gt;</p><h3 id="3）整合hystrix"><a href="#3）整合hystrix" class="headerlink" title="3）整合hystrix"></a>3）<strong>整合hystrix</strong></h3><p>Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控 和配置等功能。</p><p><img src="https://img-blog.csdnimg.cn/2021020516544827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="四、Dubbo原理"><a href="#四、Dubbo原理" class="headerlink" title="四、Dubbo原理"></a>四、Dubbo原理</h1><h3 id="1）RPC原理"><a href="#1）RPC原理" class="headerlink" title="1）RPC原理"></a>1）RPC原理</h3><p><img src="https://img-blog.csdnimg.cn/20210205165544703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>8）client stub接收消息，并进行解码</p><p><strong>9）服务消费者得到最终结果</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明发，不可见的。</p><h3 id="2-netty通信原理"><a href="#2-netty通信原理" class="headerlink" title="2)netty通信原理"></a>2)netty通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><p><img src="https://img-blog.csdnimg.cn/20210205165558801.png#pic_center" alt="在这里插入图片描述"></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MGZup9N3-1612515161931)(C:\Users\lenovo\Desktop\M5.png)]</p><h4 id="Netty原理"><a href="#Netty原理" class="headerlink" title="Netty原理"></a>Netty原理</h4><p><img src="https://img-blog.csdnimg.cn/20210205165615439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3）dubbo原理"><a href="#3）dubbo原理" class="headerlink" title="3）dubbo原理"></a>3）dubbo原理</h3><ul><li>dubbo原理-框架设计</li></ul><ul><li>dubbo原理-启动解析  加载配置信息</li></ul><ul><li>dubbo原理-服务暴漏</li></ul><ul><li>dubbo原理-服务引用</li></ul><ul><li>dubbo原理-服务调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;一、基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-分布式理论基础&quot;&gt;&lt;a href=&quot;#1-分布式理论基础&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Dubbo" scheme="https://jianier.github.io/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://jianier.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="https://jianier.github.io/2021/01/19/Shiro/"/>
    <id>https://jianier.github.io/2021/01/19/Shiro/</id>
    <published>2021-01-19T13:02:53.000Z</published>
    <updated>2021-01-21T01:48:53.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro的简介"><a href="#Shiro的简介" class="headerlink" title="Shiro的简介"></a>Shiro的简介</h1><h2 id="一-为什么学习Shiro"><a href="#一-为什么学习Shiro" class="headerlink" title="一.为什么学习Shiro?"></a>一.<strong>为什么学习Shiro?</strong></h2><p><strong>A、目前使用遇到的问题？</strong></p><ol start="2"><li>目前学习 的写的操作代码整体不太安全</li><li>使用RBAC进行角色访问控制的时候，代码书写起来相对比较麻烦</li></ol><p><strong>B、解决方案</strong></p><ol><li><strong>Spring Security  安全框架</strong>   缺点：基于Spring之上的，局限性比较大</li><li><strong>Shiro</strong>    可以在javaEE  javaSE  分布式项目上</li></ol><p><strong>C、什么是Shiro?</strong></p><p>Apache Shiro 是一个强大而灵活的开源<font color='red'>安全</font>框架，它干净利落地处理<font color='red'>身份认证</font>，<font color='orange'>授权</font>，<font color='cornflowerblue'>企业会话管理</font>和<font color='red'>加密</font>。</p><h2 id="二-Shiro中的体系组成"><a href="#二-Shiro中的体系组成" class="headerlink" title="二. Shiro中的体系组成"></a>二. Shiro中的体系组成</h2><p><img src="C:\Users\lenovo\Desktop\z.png"></p><p>Shiro的开发团队成为“<strong>应用程序的四大基石”</strong>——身份验证、授权、会话管理和加密作为其目标。</p><ul><li><strong>Authentication</strong>：<strong>身份验证</strong>/<strong>认证</strong>–有时也简称为“<strong>登录</strong>”，这是一个证明用户是他们所说的他们是谁的行为。</li><li><strong>Authorization</strong>：<strong>授权</strong>–赋予角色不同的菜单功能，访问控制的过程。</li><li><strong>Session Management</strong>：<strong>管理登录用户的信息</strong></li><li><strong>Cryptography</strong>：<strong>加密技术</strong> 比如MD5加密算法等</li></ul><p>也提供了<strong>额外的功能</strong>来支持和加强在不同环境下所关注的方面：</p><ul><li>**Web Support:**Shiro对Web项目进行的支持</li><li>**Caching:**缓存  可以安全快速的操作</li><li><strong>Concurrency</strong>：支持并发多线程的处理</li><li>**Testing:**测试</li><li>**”Run As”**：可以实现在一个用户允许的前提下，使用另一个用户访问</li><li>**”Remember Me”**：记住我</li></ul><h2 id="三-Shiro的架构"><a href="#三-Shiro的架构" class="headerlink" title="三. Shiro的架构"></a>三. Shiro的架构</h2><p><img src="C:\Users\lenovo\Desktop\w.png"></p><ul><li><strong><font color='red'>Subject</font></strong>(org.apache.shiro.subject.Subject)<br>当前与软件进行交互的实体（<font color='red'>用户</font>，<font color='orange'>第三方服务</font>，<font color='cornflowerblue'>cron job</font>，等等）的安全特定“视图”。</li><li><strong><font color='red'>SecurityManager</font></strong>(org.apache.shiro.mgt.SecurityManager)<br>如上所述，SecurityManager 是<font color='red'> Shiro 架构的心脏</font>。它基本上是一个“保护伞”对象，协调其管理的组件以确保<br>它们能够一起顺利的工作。它还管理每个应用程序用户的 Shiro 的视图，因此它知道如何执行每个用户的安全<br>操作。类似于SpringMVC中的入口Servlet即DispatchServlet</li><li><strong><font color='red'>Realms</font></strong>(org.apache.shiro.realm.Realm)<br>如上所述，Realms 在 Shiro 和你的应用程序的安全数据之间担当**<font color='red'>“桥梁”或“连接器”</font><strong>。当它实际上与安全<br>相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro 从一个或多个为应用<br>程序配置的 Realm 中寻找许多这样的东西。你可以按你的需要配置多个 Realm（通常</strong>一个数据源一个 Realm**），<br>且 Shiro 将为身份验证和授权对它们进行必要的协调。</li></ul><h2 id="四-使用Shiro实现登录的操作"><a href="#四-使用Shiro实现登录的操作" class="headerlink" title="四. 使用Shiro实现登录的操作"></a>四. 使用Shiro实现登录的操作</h2><p>第一步：导包</p><p>第二步：书写shiro.ini文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">zs=<span class="number">123</span></span><br><span class="line">sxt=root</span><br></pre></td></tr></table></figure><p>第三步：<strong>书写测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中（相当于数据源）的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h2 id="五-Shiro验证时异常分析"><a href="#五-Shiro验证时异常分析" class="headerlink" title="五. Shiro验证时异常分析"></a>五. Shiro验证时异常分析</h2><p><strong>DisabledAccountException</strong><br>账户失效异常<br><strong>ConcurrentAccessException</strong><br>竞争次数过多<br><strong>ExcessiveAttemptsException</strong><br>尝试次数过多<br><strong>UnknownAccountException</strong><br>用户名不正确<br><strong>IncorrectCredentialsException</strong><br>凭证（密码）不正确<br><strong>ExpiredCredentialsException</strong><br>凭证过期<br>使用 shiro 做异常处理的时候，尽量把<strong>异常信息表示的婉转一点</strong>，这样有助于提升代码的安全性</p><h2 id="六-Shiro的认证流程"><a href="#六-Shiro的认证流程" class="headerlink" title="六. Shiro的认证流程"></a>六. Shiro的认证流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、通过 shiro 相关的 API 创建了 SecurityManager 以及获得subject 实例</span><br><span class="line"><span class="number">2</span>、封装了 token 信息</span><br><span class="line"><span class="number">3</span>、详细描述</span><br><span class="line">通过 subject.login(token)进行用户认证</span><br><span class="line">Subject 接受 token 信息 ，通过 DelegatingSubject将 token 委托给 securityManager 完成认证</span><br><span class="line">securityManager 通过使用 DefaultSecurityManager完成相关功能,</span><br><span class="line">由 DefaultSecurityManager 中的 login 方法完成对应的认证,在 login 中调用了AuthenticatingSecurityManager中的authenticate 方法完成认证,使用其中的doAuthenticate获得realms信息,如果是单个直接进行比较，判断是否成功，如果是多个 raalm 需要使用验证策略完成对应的认证工作</span><br></pre></td></tr></table></figure><h2 id="七-Shiro的认证策略"><a href="#七-Shiro的认证策略" class="headerlink" title="七. Shiro的认证策略"></a>七. Shiro的认证策略</h2><p>定了如果有多个数据源的时候应该如何操作</p><ol><li><strong>AtLeastOneSuccessfulStrategy</strong><br>如果一个（或更多）Realm 验证成功，则整体的尝试被认为是成功的。<br>如果没有一个验证成功，<br>则整体尝试失败 类似于 java 中的 &amp;</li><li><strong>FirstSuccessfulStrategy</strong><br>只有第一个成功地验证的 Realm 返回的信息将被使用。所有进一步的<br>Realm 将被忽略。如果没有一个验证成功，则整体尝试失败。<br>类似于 java 中的 &amp;&amp;</li><li><strong>AllSucessfulStrategy</strong><br>为了整体的尝试成功，所有配置的 Realm 必须验证成功。如果没有一个验<br>证成功，则整体尝试失败</li></ol><h2 id="八-自定义Realm"><a href="#八-自定义Realm" class="headerlink" title="八. 自定义Realm"></a>八. 自定义Realm</h2><ol><li><p>为什么使用自定义Realm？</p><p>我们使用JDBCRealm的时候发现，shiro的底层自己封装了数据库表的名称和字段的名称，这样就造成了使用起来非常的不方便。</p></li><li><p>解决方案</p><p>自定义Realm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义realm：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">       <span class="comment">//authenticationToken封装了用户的信息</span></span><br><span class="line">        <span class="comment">//authenticationToken.getPrincipal()得到的是用户名比如：root</span></span><br><span class="line">        System.out.println(authenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/yjy&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ps = conn.prepareStatement(<span class="string">&quot;select pwd from admin where uname=? &quot;</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, (String) authenticationToken.getPrincipal());</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息  密码作比较</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro-jdbc2.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h2 id="九-加密算法"><a href="#九-加密算法" class="headerlink" title="九. 加密算法"></a>九. 加密算法</h2><p><strong>散列算法(算法加密)</strong></p><ol><li>在身份认证的过程中往往都会涉及到加密,如果不加密,这个时<br> 候信息就会非常的不安全,shiro 中提供的算法比较多 如 MD5、SHA 等<br> 使用 <strong>MD5</strong> 进行 ‘’1111 加密<br> b59c67bf196a4758191e42f76670ceba  单纯的进行MD5加密的话，可以通过在网上通过一张表解密，所以还要结合加盐操作进行加密<br> 进行<strong>加盐操作</strong><br> 1111+姓名=</li><li> 实现的案例</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用MD5加密</span></span><br><span class="line">        Md5Hash md5 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加盐</span></span><br><span class="line">        Md5Hash md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line">        <span class="comment">//迭代的次数(再次加盐)  迭代太多，效率会有影响</span></span><br><span class="line">        md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义Realm   加盐之后和之前自定义Realm的不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息作比较</span></span><br><span class="line">                <span class="comment">//加盐处理：ByteSource.Util.bytes(&quot;sxt&quot;)</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), ByteSource.Util.bytes(<span class="string">&quot;sxt&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>shiro.ini文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">#设置securityManager中的realm</span><br><span class="line">credentialMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">#设置加密类型</span><br><span class="line">credentialMatcher.hashAlgorithmName=md5</span><br><span class="line">#设置迭代次数</span><br><span class="line">credentialMatcher.hashIteration=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 因为自定义的UserRealm继承了AuthorizingRealm ，所以先设置AuthorizingRealm 这个里面的credentialMatcher的属性，然后再赋给UserRealm即可</span><br><span class="line">userRealm=com.bjsxt.shiro03.UserRealm</span><br><span class="line">userRealm.credentialMatcher=$credentialMatcher</span><br><span class="line">securityManager.realms=$userRealm</span><br></pre></td></tr></table></figure><h2 id="十-授权"><a href="#十-授权" class="headerlink" title="十. 授权"></a>十. 授权</h2><ol><li>授权:给身份认证通过的任授予某些资源的访问权限</li><li>权限的粒度： 粗粒度 细粒度<br><strong>粗粒度</strong><br>User 具有 CRUD 的操作 通常指的是表的操作<br><strong>细粒度</strong><br>只允许查询 id=1 的用户 使用业务代码实现<br><strong>Shiro 的授权是粗粒度</strong><br><strong>角色</strong>：角色就是权限的集合</li><li>Shiro 中代码的实现<br>详细见代码<br>Shiro 中的授权检查的 3 种方式</li></ol><ul><li><p> <strong>编程式</strong></p></li><li><p><strong>注解式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.annotation.RequiresRoles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*注解式授权*/</span></span><br><span class="line">    <span class="meta">@RequiresRoles(&quot;管理员&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>标签配置</strong>  用在web项目里面 jsp页面</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">&lt;%</span><span class="ruby">@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml">&lt;%</span><span class="ruby"><span class="variable">@taglib</span> prefix=<span class="string">&quot;shiro&quot;</span> uri=<span class="string">&quot;http://shiro.apache.org/tags&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">&lt;%-</span><span class="ruby">-标签式授权-</span><span class="xml">-%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>添加操作<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>授权详细代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;zs&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权的查询</span></span><br><span class="line">        <span class="comment">//基于角色的授权   查询单个subject.hasRole()</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = subject.hasRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个角色   subject.hasRoles()</span></span><br><span class="line">        <span class="keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (Boolean b : booleans) &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以使用checkRole判断指定用户是否具有对应角色</span></span><br><span class="line">        <span class="comment">//如果没有指定角色就会抛出异常UnauthorizedException   有的话就不报异常</span></span><br><span class="line">        subject.checkRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个角色</span></span><br><span class="line">        subject.checkRoles(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基于资源的授权  看这个用户下有没有对应的菜单</span></span><br><span class="line">        <span class="keyword">boolean</span> flag2 = subject.isPermitted(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        System.out.println(flag2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个资源</span></span><br><span class="line">        <span class="keyword">boolean</span> permittedAll = subject.isPermittedAll(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;oo&quot;</span>, <span class="string">&quot;ii&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过checkPermission进行判断指定用户下是否有指定的资源</span></span><br><span class="line">        <span class="comment">//如果没有就会抛出异常</span></span><br><span class="line">        subject.checkPermission(<span class="string">&quot;uu&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个</span></span><br><span class="line">        subject.checkPermissions(<span class="string">&quot;uu&quot;</span>, <span class="string">&quot;oo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shio.ini文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#指定具体的用户</span><br><span class="line">[users]</span><br><span class="line">#role给用户赋予角色  授权</span><br><span class="line">zs=<span class="number">123</span>,role1,role2</span><br><span class="line">sxt=root</span><br><span class="line"></span><br><span class="line">#角色的定义</span><br><span class="line">[roles]</span><br><span class="line">role1=add,update,delete</span><br><span class="line">role2=find</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#给对象中的属性赋值</span><br><span class="line">[main]</span><br></pre></td></tr></table></figure><p>  <strong>自定义 Realm  实现授权</strong><br>      我们仅仅通过配置文件指定授权是非常的不灵活的，在实际的应用中我们是将用户的信息和合权限信息保存到数据库中，我们是从数据库中获得用户的信息 ，使用 JDBCRealm 进行授权 。使用 JDBCRealm 操作的时候也不是很灵活。所以我们一般使用自定义 Realm 实现授权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义realm完成授权：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户登陆名</span></span><br><span class="line">        String username = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">        <span class="comment">//获得username，然后去数据库查询这个用户对应的角色，再根据角色查询出指定角色下对应的菜单</span></span><br><span class="line">        <span class="comment">//返回给指定角色下的所有菜单---List集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟数据库查询到该用户所对应的菜单</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;updateUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;deleteUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;addUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">            simpleAuthorizationInfo.addStringPermission(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shiro的简介&quot;&gt;&lt;a href=&quot;#Shiro的简介&quot; class=&quot;headerlink&quot; title=&quot;Shiro的简介&quot;&gt;&lt;/a&gt;Shiro的简介&lt;/h1&gt;&lt;h2 id=&quot;一-为什么学习Shiro&quot;&gt;&lt;a href=&quot;#一-为什么学习Shiro&quot; cla</summary>
      
    
    
    
    <category term="Shiro的基础知识" scheme="https://jianier.github.io/categories/Shiro%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Shiro" scheme="https://jianier.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题</title>
    <link href="https://jianier.github.io/2021/01/18/Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>https://jianier.github.io/2021/01/18/Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-01-18T11:55:12.000Z</published>
    <updated>2021-01-18T12:09:52.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="721题—账户合并"><a href="#721题—账户合并" class="headerlink" title="721题—账户合并"></a>721题—<font color='orange'>账户合并</font></h2><p>题目：<a href="https://leetcode-cn.com/problems/accounts-merge">力扣</a></p><h3 id="知识点：并查集-哈希表"><a href="#知识点：并查集-哈希表" class="headerlink" title="知识点：并查集+哈希表"></a>知识点：并查集+哈希表</h3><p><strong>一。什么是并查集？</strong>？</p><p><a href="https://baike.sogou.com/v54997185.htm?fromTitle=%E5%B9%B6%E6%9F%A5%E9%9B%86">百度百科</a></p><p>并查集是一种<strong>树型</strong> 的数据结构，用于处理一些不交集的合并及查询问题。顾名思义，就是交集为空集的集合。有一个<strong>联合-查找算法</strong>定义了两个用于此数据结构的操作：</p><p><strong>Find：</strong>确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集。</p><p><strong>Union</strong>：将两个子集合并成同一个集合</p><p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为<strong>代表</strong>，表示整个集合。接着，<strong>Find(x) ** 返回x所属集合的代表，而</strong>Union**使用两个集合的代表作为参数</p><p>对于并查集，主要有如下操作：</p><ol><li><strong>合并两个集合(“并”)</strong></li><li><strong>判断两个元素是否属于同一个集合(“查“）</strong></li></ol><p>知乎上有一个通俗易懂的帖子，有助于理解<strong>并查集</strong>。<a href="https://zhuanlan.zhihu.com/p/35314141">并查集</a></p><p>对于并查集还有两个优化：<font color='red'><strong>路径压缩和按秩合并</strong></font></p><p><strong>二.解题思路</strong></p><p>根据题意可知：</p><ul><li><strong>存在相同邮箱的账号一定属于同一个人</strong></li><li><strong>名称相同的账户不一定属于同一个人</strong></li></ul><p><a href="https://leetcode-cn.com/problems/accounts-merge/solution/tu-jie-yi-ran-shi-bing-cha-ji-by-yexiso-5ncf/">题解</a></p><p><img src="C:\Users\lenovo\Desktop\账户合并.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        UnionFind myUnion = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                String curEmail = accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> id = myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;721题—账户合并&quot;&gt;&lt;a href=&quot;#721题—账户合并&quot; class=&quot;headerlink&quot; title=&quot;721题—账户合并&quot;&gt;&lt;/a&gt;721题—&lt;font color=&#39;orange&#39;&gt;账户合并&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;题目：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="Leetcode每日一题" scheme="https://jianier.github.io/categories/Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://jianier.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <link href="https://jianier.github.io/2021/01/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jianier.github.io/2021/01/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-01-17T12:17:53.000Z</published>
    <updated>2021-01-17T13:06:15.147Z</updated>
    
    
    
    
    <category term="Hexo" scheme="https://jianier.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>RBAC</title>
    <link href="https://jianier.github.io/2021/01/17/RBAC/"/>
    <id>https://jianier.github.io/2021/01/17/RBAC/</id>
    <published>2021-01-17T12:16:52.000Z</published>
    <updated>2021-01-19T09:23:51.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RBAC学习"><a href="#RBAC学习" class="headerlink" title="RBAC学习"></a>RBAC学习</h1><h2 id="一-什么是RBAC？"><a href="#一-什么是RBAC？" class="headerlink" title="一. 什么是RBAC？"></a>一. 什么是RBAC？</h2><p>RBAC(Role-Based Access Control)基于角色的访问控制。这种模型（用户-角色-权限模型）的基本概念是把许可权与角色联系在一起，用户通过充当合适角色的成员而获得该角色的许可权。一个用户拥有若干个角色，每一个角色拥有若干个权限。在这种模型中，用户与角色之间，角色与权限(功能)之间，一般都是多对多的关系。</p><p>RBAC重要对象：</p><ol><li><strong>用户</strong>：角色施加的主体；用户通过拥有某个或多个角色以得到对应的权限</li><li><strong>角色</strong>：一组权限的集合</li><li><strong>权限</strong>：用于限定能够访问的一个资源</li></ol><p>权限赋予给角色，而把角色又赋予用户</p><h2 id="二-RBAC级别"><a href="#二-RBAC级别" class="headerlink" title="二.RBAC级别"></a>二.RBAC级别</h2><h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>定义了能构成一个RBAC控制系统的最小的元素集合，<strong>RBAC0是RBAC的核心模型</strong>，其他的级别都是建立在该级别的基础上。</p><p>主要由四部分组成：</p><ol><li>用户</li><li>角色</li><li>许可</li><li>会话</li></ol><p>在RBAC之中，包含用户users(USERS)、角色roles(ROLES)、目标objects(OBS)、操作operations(OPS)、许可权permissions(PRMS)五个基本数据元素，<font color='orange'>权限被赋予角色</font>,而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的权限，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展</p><p><img src="C:\Users\lenovo\Desktop\y.png"></p><h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>引入角色之间的继承关系，进行了角色的分层，也就是说有了上下级别的关系。</p><p>角色之间的继承关系可以分为继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构。</p><p>RBAC1是对RBAC0进行了扩展，是RBAC的角色分层模型，RBAC1引入了角色继承概念，有了继承就有了上下级的包含关系。</p><h3 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h3><p>该模型中添加了责任分离关系</p><p>一些特殊的角色是不能赋予给一个用户的，比如：财务当中的会计和出纳角色不能同时赋予给一个人</p><h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>RBAC3包含了RBAC1和RBAC2，既提供了角色间的继承关系，又提供了责任分离关系</p><h1 id="三-RBAC实战案例"><a href="#三-RBAC实战案例" class="headerlink" title="三.RBAC实战案例"></a>三.RBAC实战案例</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1   需求"></a>1   需求</h2><ol><li>实现用户登录功能</li><li>使用RBAC0模型管理系统权限</li><li>对系统的菜单以及菜单中的链接进行管理</li><li>用户登录后首页根据用户角色显示该角色所对应的菜单</li><li>禁止用户越级访问</li></ol><h2 id="2-技术选择"><a href="#2-技术选择" class="headerlink" title="2  技术选择"></a>2  技术选择</h2><ol><li>框架：SpringMVC+Spring+Mybatis</li><li>数据库：Mysql</li></ol><h2 id="3-数据库设计"><a href="#3-数据库设计" class="headerlink" title="3  数据库设计"></a>3  数据库设计</h2><p>数据库的设计表</p><h2 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4 权限管理"></a>4 权限管理</h2><h3 id="1越级访问"><a href="#1越级访问" class="headerlink" title="1越级访问"></a>1越级访问</h3><p>所谓越级访问就是使用低级本的角色访问高级别的资源</p><p><strong>DTree</strong></p><p><strong>在菜单生成的过程中，所有的功能都落脚于子结点上，页面的树型菜单就很难生成，外连接可以查到孤儿数据的</strong></p><p><strong>权限过滤器</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RBAC学习&quot;&gt;&lt;a href=&quot;#RBAC学习&quot; class=&quot;headerlink&quot; title=&quot;RBAC学习&quot;&gt;&lt;/a&gt;RBAC学习&lt;/h1&gt;&lt;h2 id=&quot;一-什么是RBAC？&quot;&gt;&lt;a href=&quot;#一-什么是RBAC？&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="RBAC" scheme="https://jianier.github.io/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法学习 &amp;&amp;  Typora工具的使用</title>
    <link href="https://jianier.github.io/2021/01/17/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-Typora%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://jianier.github.io/2021/01/17/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-Typora%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-17T06:44:24.000Z</published>
    <updated>2021-01-17T13:05:49.396Z</updated>
    
    
    
    
    <category term="markdown使用" scheme="https://jianier.github.io/categories/markdown%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="markdown" scheme="https://jianier.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://jianier.github.io/2021/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://jianier.github.io/2021/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-17T06:40:03.000Z</published>
    <updated>2021-01-18T12:03:07.780Z</updated>
    
    <content type="html"><![CDATA[<p>为了可以让新接触算法的小白可以更快对算法有一个直观的认识，先给大家引出几个经典算法题来激发大家对算法的兴趣，毕竟不会算法的程序员不是一个好的程序员，希望大家可以对算法有一个很好的重视。要明白算法是程序的灵魂，如果不想成为代码工人，那就花时间来研究数据结构和算法，程序=数据结构+算法。数据结构是算法的基础，想学好算法。需要把数据结构学到位。</p><h2 id="一-引出几个经典的算法面试题"><a href="#一-引出几个经典的算法面试题" class="headerlink" title="一. 引出几个经典的算法面试题##"></a>一. 引出几个经典的算法面试题##</h2><h3 id="1-1字符串匹配问题"><a href="#1-1字符串匹配问题" class="headerlink" title="1.1字符串匹配问题"></a>1.1字符串匹配问题</h3><ul><li>算法：暴力匹配(简单、但是效率低)、KMP算法(部分匹配表)——面试题会用这个算法来解决</li><li>要求：用最快的速度来完成匹配、</li><li>思路是什么？</li></ul><h3 id="1-2汉诺塔游戏"><a href="#1-2汉诺塔游戏" class="headerlink" title="1.2汉诺塔游戏"></a>1.2汉诺塔游戏</h3><p>将A塔的所有圆盘移动到C塔并且规定，小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘<br><img src="https://github.com/jianier/pictureRepo/blob/master/5.png" alt="image"></p><h3 id="1-3八皇后问题——回溯算法的经典案例"><a href="#1-3八皇后问题——回溯算法的经典案例" class="headerlink" title="1.3八皇后问题——回溯算法的经典案例"></a>1.3八皇后问题——回溯算法的经典案例</h3><p>1)即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？<br>2)用图论的方法解出有92种<br>3)分治算法</p><h3 id="1-4马踏棋盘算法又称骑士周游问题"><a href="#1-4马踏棋盘算法又称骑士周游问题" class="headerlink" title="1.4马踏棋盘算法又称骑士周游问题"></a>1.4马踏棋盘算法又称骑士周游问题</h3><p>1)将马随机放在国际象棋的8×8棋盘的某个方格中。马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。<br><img src="C:\Users\lenovo\Desktop\6.png" alt="avatar"><br>2)会使用到图图的深度优化遍历算法(DFS)+贪心算法优化<br>#二. 数据结构<br>##2.1线性和非线性结构  ##</p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>2.1.1 线性结构的特点：数据元素之间存在“一对一的”线性关系<br>2.1.2 线性结构有两种不同的存储结构：<br>1）顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表种的存储元素是连续的<br>2）链式存储的线性表称为链表，链表种的存储元素“不一定是连续的”，元素节点中存放数据元素以及相邻元素的地址信息<br>2.1.3 线性结构常见的有:数组、队列、链表和栈</p><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>1）非线性结构包括：二维数组、多维数组、广义表、树结构、图结构<br>##2.2稀疏数组和队列  ##</p><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>2.2.1应用：五子棋存盘退出和续上盘 、地图<br>2.2.2概念：当一个数组种大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是：<br>1）记录数组一工有几行几列，有多少个不同的值<br>2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。<br><img src="https://github.com/jianier/pictureRepo/blob/master/7.png" alt="image"></p><h3 id="2-2-3-二维数组转稀疏数组的思路"><a href="#2-2-3-二维数组转稀疏数组的思路" class="headerlink" title="2.2.3 二维数组转稀疏数组的思路"></a>2.2.3 二维数组转稀疏数组的思路</h3><p>1）遍历 原始的二维数组，得到有效数据的个数sum<br>2)根据sum就可以创建稀疏数组sparseArr  int[sum+1][3]<br>3)将二维数组的有效数据存入到稀疏数组中 </p><h3 id="2-2-4-稀疏数组转二维数组的思路"><a href="#2-2-4-稀疏数组转二维数组的思路" class="headerlink" title="2.2.4 稀疏数组转二维数组的思路"></a>2.2.4 稀疏数组转二维数组的思路</h3><p>1）先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。比如上面的chessArr2=int[11][11]<br>2）在读取稀疏数组后几行的数据，并赋给原始的二维数组<br><img src="https://github.com/jianier/pictureRepo/blob/master/8.png" alt="image"><br>##2.3链表 ##</p><h3 id="2-3-1链表"><a href="#2-3-1链表" class="headerlink" title="2.3.1链表"></a>2.3.1链表</h3><h3 id="2-3-2单链表"><a href="#2-3-2单链表" class="headerlink" title="2.3.2单链表"></a>2.3.2单链表</h3><h3 id="2-3-3双向链表"><a href="#2-3-3双向链表" class="headerlink" title="2.3.3双向链表"></a>2.3.3双向链表</h3><h3 id="2-3-4单向环形链表"><a href="#2-3-4单向环形链表" class="headerlink" title="2.3.4单向环形链表"></a>2.3.4单向环形链表</h3><h2 id="2-4栈"><a href="#2-4栈" class="headerlink" title="2.4栈"></a>2.4栈</h2><h2 id="2-5前缀、中缀、后缀表达式-逆波兰表达式"><a href="#2-5前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="2.5前缀、中缀、后缀表达式(逆波兰表达式)"></a>2.5前缀、中缀、后缀表达式(逆波兰表达式)</h2><h3 id="2-5-1逆波兰计算器"><a href="#2-5-1逆波兰计算器" class="headerlink" title="2.5.1逆波兰计算器"></a>2.5.1逆波兰计算器</h3><h2 id="2-6递归"><a href="#2-6递归" class="headerlink" title="2.6递归"></a>2.6递归</h2><h3 id="2-6-1迷宫问题"><a href="#2-6-1迷宫问题" class="headerlink" title="2.6.1迷宫问题"></a>2.6.1迷宫问题</h3><h3 id="2-6-2八皇后问题-回溯算法"><a href="#2-6-2八皇后问题-回溯算法" class="headerlink" title="2.6.2八皇后问题(回溯算法)"></a>2.6.2八皇后问题(回溯算法)</h3><h2 id="2-7八大排序算法"><a href="#2-7八大排序算法" class="headerlink" title="2.7八大排序算法"></a>2.7八大排序算法</h2><h3 id="2-7-1内部-使用内存-排序栈"><a href="#2-7-1内部-使用内存-排序栈" class="headerlink" title="2.7.1内部(使用内存)排序栈"></a>2.7.1内部(使用内存)排序栈</h3><ol><li>插入排序：<br>1.1直接插入排序<br>1.2希尔排序</li><li>选择排序<br>2.1简单选择排序<br>2.2堆排序</li><li>交换排序<br>3.1冒泡排序<br>3.2快速排序 </li><li>归并排序</li><li>基数排序(桶排序)<h3 id="2-7-2外部-使用内存和外存结合-排序栈"><a href="#2-7-2外部-使用内存和外存结合-排序栈" class="headerlink" title="2.7.2外部(使用内存和外存结合)排序栈"></a>2.7.2外部(使用内存和外存结合)排序栈</h3><h2 id="2-8算法的时间复杂度"><a href="#2-8算法的时间复杂度" class="headerlink" title="2.8算法的时间复杂度"></a>2.8算法的时间复杂度</h2></li></ol><ul><li><p>常数阶  </p></li><li><p>对数阶  </p></li><li><p>线性阶  </p></li><li><p>线性对数阶  </p></li><li><p>平方阶  </p></li><li><p>立方阶  </p></li><li><p>k次方阶  </p></li><li><p>指数阶级O(2^n)<br>##2.9查找算法##</p></li></ul><ol><li>线性查找算法</li><li>二分查找算法</li><li>插值查找算法</li><li>斐波那契(黄金分割)算法<h2 id="2-10哈希表"><a href="#2-10哈希表" class="headerlink" title="2.10哈希表##"></a>2.10哈希表##</h2><h2 id="2-11树"><a href="#2-11树" class="headerlink" title="2.11树##"></a>2.11树##</h2></li><li>二叉树</li><li>顺序存储二叉树</li><li>线索化二叉树<h2 id="2-12树结构的实际应用"><a href="#2-12树结构的实际应用" class="headerlink" title="2.12树结构的实际应用##"></a>2.12树结构的实际应用##</h2></li></ol><ul><li>堆排序</li><li>赫夫曼树</li><li>赫夫曼编码<br>1)最佳实践-数据压缩(创建赫夫曼树)<br>2)最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)<br>3）最佳实践-数据解压(使用赫夫曼编码)<br>4）最佳实践-文件压缩<br>5）最佳实践-文件解压(文件恢复)  </li><li>二叉排序树</li><li>平衡二叉树(AVL树)</li><li>多路查找树<br>二叉树与B树<br>2-3树<br>B树、B+树和B*树<br>##2.12图##</li></ul><ol><li>图的创建和深度优先搜索算法</li></ol><h1 id="三-算法"><a href="#三-算法" class="headerlink" title="三.算法"></a>三.算法</h1><h2 id="3-1二分查找算法-非递归"><a href="#3-1二分查找算法-非递归" class="headerlink" title="3.1二分查找算法(非递归)##"></a>3.1二分查找算法(非递归)##</h2><h2 id="3-2分治算法"><a href="#3-2分治算法" class="headerlink" title="3.2分治算法##"></a>3.2分治算法##</h2><p>汉诺塔</p><h2 id="3-3动态规划算法"><a href="#3-3动态规划算法" class="headerlink" title="3.3动态规划算法##"></a>3.3动态规划算法##</h2><p>0-1背包问题</p><h2 id="3-4KMP算法"><a href="#3-4KMP算法" class="headerlink" title="3.4KMP算法##"></a>3.4KMP算法##</h2><h2 id="3-5贪心算法"><a href="#3-5贪心算法" class="headerlink" title="3.5贪心算法##"></a>3.5贪心算法##</h2><p>集合覆盖问题</p><h2 id="3-6普利姆算法"><a href="#3-6普利姆算法" class="headerlink" title="3.6普利姆算法##"></a>3.6普利姆算法##</h2><p>修路问题</p><h2 id="3-7克鲁斯卡尔算法"><a href="#3-7克鲁斯卡尔算法" class="headerlink" title="3.7克鲁斯卡尔算法##"></a>3.7克鲁斯卡尔算法##</h2><p>公交站问题</p><h2 id="3-8迪杰斯特拉算法-Dijksta"><a href="#3-8迪杰斯特拉算法-Dijksta" class="headerlink" title="3.8迪杰斯特拉算法(Dijksta)##"></a>3.8迪杰斯特拉算法(Dijksta)##</h2><p>最短路径算法</p><h2 id="3-9弗洛伊德算法-Floyd"><a href="#3-9弗洛伊德算法-Floyd" class="headerlink" title="3.9弗洛伊德算法(Floyd)##"></a>3.9弗洛伊德算法(Floyd)##</h2><p>弗洛伊德算法vs迪杰斯特拉算法</p><h2 id="3-10马踏棋盘算法"><a href="#3-10马踏棋盘算法" class="headerlink" title="3.10马踏棋盘算法##"></a>3.10马踏棋盘算法##</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了可以让新接触算法的小白可以更快对算法有一个直观的认识，先给大家引出几个经典算法题来激发大家对算法的兴趣，毕竟不会算法的程序员不是一个好的程序员，希望大家可以对算法有一个很好的重视。要明白算法是程序的灵魂，如果不想成为代码工人，那就花时间来研究数据结构和算法，程序=数据结</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://jianier.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://jianier.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机学习</title>
    <link href="https://jianier.github.io/2021/01/17/JVM%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jianier.github.io/2021/01/17/JVM%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-17T06:33:22.000Z</published>
    <updated>2021-01-18T12:02:13.709Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JVM的整体结构  </li><li>Java代码执行流程  </li><li>JVM的架构模型    </li><li>JVM的生命周期   </li><li>JVM的发展历程  </li></ul><p>开发人员如何看待上层框架？<br>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。<br>如果我们把核心类库的API比作数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。  </p><p>为什么要学习JVM？<br>1）面试的需要(BATJ 京东、TMD 今日头条美团 滴滴、PKQ拼多多 快手趣多多等面试都爱问)<br>2）中高级程序员必备技能：项目管理、调优的需要<br>3）追求极客的精神<br>比如：垃圾回收算法、JIT即时编译器、底层原理 </p><h1 id="一-JVM与Java体系结构"><a href="#一-JVM与Java体系结构" class="headerlink" title="一.JVM与Java体系结构"></a>一.JVM与Java体系结构</h1><p>Java的基本概念</p><p>Java虚拟机根本不关心运行在其内部的程序到底如何使用何种编程语言编写的 ，它$\textcolor{Magenta}{只关心“字节码”文件}$，也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><h1 id="二-类加载子系统"><a href="#二-类加载子系统" class="headerlink" title="二.类加载子系统"></a>二.类加载子系统</h1><h1 id="三-运行时数据取概述及线程"><a href="#三-运行时数据取概述及线程" class="headerlink" title="三.运行时数据取概述及线程"></a>三.运行时数据取概述及线程</h1><h1 id="四-程序计数器"><a href="#四-程序计数器" class="headerlink" title="四.程序计数器"></a>四.程序计数器</h1><h1 id="五-虚拟机栈"><a href="#五-虚拟机栈" class="headerlink" title="五.虚拟机栈"></a>五.虚拟机栈</h1><h1 id="六-本地方法接口"><a href="#六-本地方法接口" class="headerlink" title="六.本地方法接口"></a>六.本地方法接口</h1><h1 id="七-本地方法栈"><a href="#七-本地方法栈" class="headerlink" title="七.本地方法栈"></a>七.本地方法栈</h1><h1 id="八-堆"><a href="#八-堆" class="headerlink" title="八.堆"></a>八.堆</h1><h1 id="九-方法区"><a href="#九-方法区" class="headerlink" title="九. 方法区"></a>九. 方法区</h1><h1 id="十-直接内存"><a href="#十-直接内存" class="headerlink" title="十.直接内存"></a>十.直接内存</h1><h1 id="十一-执行引擎"><a href="#十一-执行引擎" class="headerlink" title="十一.执行引擎"></a>十一.执行引擎</h1><h1 id="十二-String-Table"><a href="#十二-String-Table" class="headerlink" title="十二. String  Table"></a>十二. String  Table</h1><h1 id="十三-垃圾回收概述"><a href="#十三-垃圾回收概述" class="headerlink" title="十三.垃圾回收概述"></a>十三.垃圾回收概述</h1><h1 id="十四-垃圾回收相关算法"><a href="#十四-垃圾回收相关算法" class="headerlink" title="十四. 垃圾回收相关算法"></a>十四. 垃圾回收相关算法</h1><h1 id="十五-垃圾回收相关概念"><a href="#十五-垃圾回收相关概念" class="headerlink" title="十五 垃圾回收相关概念"></a>十五 垃圾回收相关概念</h1><h1 id="十六-垃圾回收器"><a href="#十六-垃圾回收器" class="headerlink" title="十六. 垃圾回收器"></a>十六. 垃圾回收器</h1>]]></content>
    
    
    <summary type="html">java虚拟机学习</summary>
    
    
    
    <category term="JVM虚拟机学习" scheme="https://jianier.github.io/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java底层源码" scheme="https://jianier.github.io/tags/Java%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
