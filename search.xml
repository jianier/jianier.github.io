<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode每日一题</title>
    <url>/2021/01/18/Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="721题—账户合并"><a href="#721题—账户合并" class="headerlink" title="721题—账户合并"></a>721题—<font color='orange'>账户合并</font></h2><p>题目：<a href="https://leetcode-cn.com/problems/accounts-merge">力扣</a></p>
<h3 id="知识点：并查集-哈希表"><a href="#知识点：并查集-哈希表" class="headerlink" title="知识点：并查集+哈希表"></a>知识点：并查集+哈希表</h3><p><strong>一。什么是并查集？</strong>？</p>
<p><a href="https://baike.sogou.com/v54997185.htm?fromTitle=%E5%B9%B6%E6%9F%A5%E9%9B%86">百度百科</a></p>
<p>并查集是一种<strong>树型</strong> 的数据结构，用于处理一些不交集的合并及查询问题。顾名思义，就是交集为空集的集合。有一个<strong>联合-查找算法</strong>定义了两个用于此数据结构的操作：</p>
<p><strong>Find：</strong>确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集。</p>
<p><strong>Union</strong>：将两个子集合并成同一个集合</p>
<p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为<strong>代表</strong>，表示整个集合。接着，<strong>Find(x) ** 返回x所属集合的代表，而</strong>Union**使用两个集合的代表作为参数</p>
<p>对于并查集，主要有如下操作：</p>
<ol>
<li><strong>合并两个集合(“并”)</strong></li>
<li><strong>判断两个元素是否属于同一个集合(“查“）</strong></li>
</ol>
<p>知乎上有一个通俗易懂的帖子，有助于理解<strong>并查集</strong>。<a href="https://zhuanlan.zhihu.com/p/35314141">并查集</a></p>
<p>对于并查集还有两个优化：<font color='red'><strong>路径压缩和按秩合并</strong></font></p>
<p><strong>二.解题思路</strong></p>
<p>根据题意可知：</p>
<ul>
<li><strong>存在相同邮箱的账号一定属于同一个人</strong></li>
<li><strong>名称相同的账户不一定属于同一个人</strong></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/accounts-merge/solution/tu-jie-yi-ran-shi-bing-cha-ji-by-yexiso-5ncf/">题解</a></p>
<p><img src="C:\Users\lenovo\Desktop\账户合并.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        UnionFind myUnion = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                String curEmail = accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> id = myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2021/02/05/Dubbo/</url>
    <content><![CDATA[<h1 id="Dubbo学习"><a href="#Dubbo学习" class="headerlink" title="Dubbo学习"></a>Dubbo学习</h1><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-分布式理论基础"><a href="#1-分布式理论基础" class="headerlink" title="1. 分布式理论基础"></a>1. 分布式理论基础</h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a>1.1 什么是分布式系统？</h3><p>分布式系统(distributed system)是建立在网络之上的软件系统。</p>
<p>随着互连网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需    一个<strong>治理系统</strong>（比如说Dubbo）确保架构有条不紊的演进。</p>
<h3 id="1-2-发展演变"><a href="#1-2-发展演变" class="headerlink" title="1.2 发展演变"></a>1.2 发展演变</h3><pre><code>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210205104436391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center)</code></pre>
<ul>
<li><p><strong>单一应用架构</strong> 比如：超市的收银系统、公司的管理系统、小型的网站应用</p>
<ul>
<li><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</p>
</li>
<li><p>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205104557417.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>缺点</strong>：</p>
<p>扩展应用(带着整个应用扩展)不容易、协调开发不容易(同时在一个上去开发)</p>
</li>
<li><p><strong>垂直应用架构</strong></p>
<ul>
<li><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</p>
</li>
<li><p>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104459438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>每一个模块从页面、业务逻辑、程序、数据库都是完整的</p>
<p><strong>优点</strong>：开发和维护不同的应用互不干扰、性能扩展容易、</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>界面+业务逻辑的实现分离</li>
<li><strong>应用之间不可能完全独立，大量的应用之间需要交互</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>分布式服务架构</strong> </p>
<ul>
<li><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p>
</li>
<li><p>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104517127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>优点</strong>：把核心业务抽取出来，只需要改动界面即可。服务器上的核心业务还在服务器上。</p>
<p><strong>缺点</strong>：不能实时管理服务器。造成浪费</p>
<p><strong>分布式服务框架(RPC)：</strong>远程过程调用 </p>
<p>分布式架构的<strong>难点</strong>就是如何拆分业务+如何远程过程调用</p>
</li>
</ul>
</li>
<li><p><strong>流动计算架构</strong> </p>
<ul>
<li><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</p>
</li>
<li><p>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104534489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>负责维护整个服务集群，可以实时的管理集群容量，比如A服务器访问量大了，可以给A动态的多来几台。</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-RPC"><a href="#1-3-RPC" class="headerlink" title="1.3 RPC"></a>1.3 RPC</h3><p><strong>什么叫RPC？</strong></p>
<p><strong>RPC【Remote Procedure Call】</strong>是指远程过程调用，是一种进程间的通信方式，它是一种技术思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显示编码这个远程调用的细节。即程序员无论是调用本地还是远程的函数，本质上编写的调用代码基本相同。</p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210205104635464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>通俗说来就是A和B两个服务器建立起一个网络连接，他们之间进行通信。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104619296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>影响RPC机制的两个因素就是<strong>①序列化和反序列化机制的速度②能否快速的在各个服务器之间建立连接即通信效率</strong></p>
<p><strong>RPC的两个核心模块：通信、序列化</strong></p>
<p><strong>RPC 框架有很多如：</strong></p>
<p><strong>dubbo、</strong>gRPC、Thrift、HSF(High Speed Service Framework)</p>
<h1 id="二、Dubbo配置"><a href="#二、Dubbo配置" class="headerlink" title="二、Dubbo配置"></a>二、Dubbo配置</h1><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2. Dubbo核心概念"></a>2. Dubbo核心概念</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>Apache Dubbo</strong>是一款高性能、轻量级的开源Java RPC框架，他提供了三大核心能力：<strong>①面向接口的远程方法调用，②智能容错和负载均衡，以及③服务自动注册和发现。</strong></p>
<p>官网：<a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></p>
<p><strong>Dubbo的特性；</strong></p>
<ul>
<li><p>面向<strong>接口</strong>代理的高性能RPC调用：为开发者屏蔽远程调用底层细节</p>
</li>
<li><p>服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104655848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>  <strong>注册中心</strong>相当于所有服务都在哪个服务器上的一个清单比如支付业务在4 6 9服务器上有安装负载均衡看选择哪个服务器合适</p>
<ul>
<li><p>运行期流量调度：内置条件、脚本等路由策略</p>
</li>
<li><p>智能负载均衡</p>
</li>
<li><p>高度可扩展能力：遵循微内核+插件的设计原则</p>
</li>
<li><p>可视化的服务治理与运维</p>
</li>
</ul>
<h3 id="2-2高性能Java-RPC框架——Dubbo设计框架"><a href="#2-2高性能Java-RPC框架——Dubbo设计框架" class="headerlink" title="2.2高性能Java RPC框架——Dubbo设计框架"></a>2.2高性能Java RPC框架——Dubbo设计框架</h3><p><img src="https://img-blog.csdnimg.cn/20210205104713663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
</li>
<li><p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
</li>
<li><p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
</li>
<li><p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
</li>
</ul>
<h3 id="2-3-zookeeper注册中心"><a href="#2-3-zookeeper注册中心" class="headerlink" title="2.3 zookeeper注册中心"></a>2.3 zookeeper注册中心</h3><p><strong>Zookeeper</strong>是Apache Hadoop的子项目，是一个树型的目录结构，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104734728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-dubbo-helloword实例"><a href="#3-dubbo-helloword实例" class="headerlink" title="3.dubbo-helloword实例"></a>3.dubbo-helloword实例</h2><h3 id="3-1提出需求"><a href="#3-1提出需求" class="headerlink" title="3.1提出需求"></a>3.1提出需求</h3><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>订单服务web模块</td>
<td>创建订单等</td>
</tr>
<tr>
<td>用户服务service模块</td>
<td>查询用户地址等</td>
</tr>
</tbody></table>
<p>测试预期结果：</p>
<pre><code>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210205104752913.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>本地存根</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210205165308490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringBoot与dubbo整合的三种方式：</strong></p>
<p>1）导入dubbo-starter依赖，在application.properties配置属性，使用@Service【暴力服务】和使用@Reference【 引用服务】，同时还要在启动类中开启dubbo注解功能@EnableDubbo</p>
<p>2）保留dubbo.xml配置文件;</p>
<p>导入dubbo-start依赖、使用@ImportResource导入dubbo的配置文件即可【在启动类中配置@ImportResource(location=”classpath:provider.xml”)】</p>
<p>3）使用注解API方式；</p>
<p>将原先配置文件xml中的每一个组件通过手动创建到容器中，即写一个配置类@Configuration，将每一个组件通过@Bean注入到容器中、在启动类中使用@DubboComponentScan()或者用@EnableDubbo(scanBasePackages=”包名”)  @Service注解暴露出来</p>
<h1 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h1><h2 id="1、zookeeper宕机与dubbo直连"><a href="#1、zookeeper宕机与dubbo直连" class="headerlink" title="1、zookeeper宕机与dubbo直连"></a>1、zookeeper宕机与dubbo直连</h2><p>zookeeper注册中心宕机，还可以消费dubbo暴漏的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍然能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍然能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等服务提供者恢复</li>
</ul>
<p>高可用：通过设计，减少系统不能提供服务的时间</p>
<p><strong>dubbo直连</strong></p>
<p>直接绕过注册中心与服务相连，是通过@Reference注解中直接设置服务提供者的url</p>
<h2 id="2、集群下dubbo负载均衡配置"><a href="#2、集群下dubbo负载均衡配置" class="headerlink" title="2、集群下dubbo负载均衡配置"></a>2、集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随即调用</p>
<p><strong>负载均衡策略：</strong></p>
<ul>
<li><p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165330907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li><p>RoundRobin LoadBalance</p>
<p>轮询，按公约后 的权重设置轮询比率。</p>
<p>存在慢的提供者累计请求的问题，比如，第二台机器很慢，但没挂，当请求调到第二台时就卡在那 ，久而久之，所有请求都卡在调到第二台上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165342580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>LeastActive LoadBalance</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少的请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205165356499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性Hash，相同参数的请求总是发到同一提供者</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平衡到其他提供者，不会引起剧烈变动。算法参见:<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
<p>缺省只对第一个参数Hash，如果要修改，请配置&lt;dubbo:parameter key=”hash.arguments” value=”0.1”/&gt;</p>
<p>缺省用160份虚拟节点，如果要修改，请配置&lt;dubbo:parameter key=”hash.nodes” value=”320”/&gt;</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205165408957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-整合hystrix，服务容错"><a href="#3-整合hystrix，服务容错" class="headerlink" title="3.整合hystrix，服务容错"></a>3.整合hystrix，服务容错</h2><h3 id="1）什么是服务降级？"><a href="#1）什么是服务降级？" class="headerlink" title="1）什么是服务降级？"></a>1）什么是<strong>服务降级</strong>？</h3><p><strong>当服务器压力剧增的情况下，根据实际业务及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作</strong>。</p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165421518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2）集群容错"><a href="#2）集群容错" class="headerlink" title="2）集群容错"></a>2）<strong>集群容错</strong></h3><p>在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。</p>
<p><strong>集群容错模式</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165434577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>集群模式配置：</strong></p>
<p>按照一下示例在服务提供方和消费方配置集群模式</p>
<p>&lt;dubbo:service cluste”failsafe/&gt;</p>
<p>或</p>
<p>&lt;dubbo:reference cluste”failsafe/&gt;</p>
<h3 id="3）整合hystrix"><a href="#3）整合hystrix" class="headerlink" title="3）整合hystrix"></a>3）<strong>整合hystrix</strong></h3><p>Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控 和配置等功能。</p>
<p><img src="https://img-blog.csdnimg.cn/2021020516544827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="四、Dubbo原理"><a href="#四、Dubbo原理" class="headerlink" title="四、Dubbo原理"></a>四、Dubbo原理</h1><h3 id="1）RPC原理"><a href="#1）RPC原理" class="headerlink" title="1）RPC原理"></a>1）RPC原理</h3><p><img src="https://img-blog.csdnimg.cn/20210205165544703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>8）client stub接收消息，并进行解码</p>
<p><strong>9）服务消费者得到最终结果</strong></p>
<p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明发，不可见的。</p>
<h3 id="2-netty通信原理"><a href="#2-netty通信原理" class="headerlink" title="2)netty通信原理"></a>2)netty通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165558801.png#pic_center" alt="在这里插入图片描述"></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MGZup9N3-1612515161931)(C:\Users\lenovo\Desktop\M5.png)]</p>
<h4 id="Netty原理"><a href="#Netty原理" class="headerlink" title="Netty原理"></a>Netty原理</h4><p><img src="https://img-blog.csdnimg.cn/20210205165615439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3）dubbo原理"><a href="#3）dubbo原理" class="headerlink" title="3）dubbo原理"></a>3）dubbo原理</h3><ul>
<li>dubbo原理-框架设计</li>
</ul>
<ul>
<li>dubbo原理-启动解析  加载配置信息</li>
</ul>
<ul>
<li>dubbo原理-服务暴漏</li>
</ul>
<ul>
<li>dubbo原理-服务引用</li>
</ul>
<ul>
<li>dubbo原理-服务调用</li>
</ul>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机学习</title>
    <url>/2021/01/17/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li>JVM的整体结构  </li>
<li>Java代码执行流程  </li>
<li>JVM的架构模型    </li>
<li>JVM的生命周期   </li>
<li>JVM的发展历程  </li>
</ul>
<p>开发人员如何看待上层框架？<br>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。<br>如果我们把核心类库的API比作数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。  </p>
<p>为什么要学习JVM？<br>1）面试的需要(BATJ 京东、TMD 今日头条美团 滴滴、PKQ拼多多 快手趣多多等面试都爱问)<br>2）中高级程序员必备技能：项目管理、调优的需要<br>3）追求极客的精神<br>比如：垃圾回收算法、JIT即时编译器、底层原理 </p>
<h1 id="一-JVM与Java体系结构"><a href="#一-JVM与Java体系结构" class="headerlink" title="一.JVM与Java体系结构"></a>一.JVM与Java体系结构</h1><p>Java的基本概念</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底如何使用何种编程语言编写的 ，它$\textcolor{Magenta}{只关心“字节码”文件}$，也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h1 id="二-类加载子系统"><a href="#二-类加载子系统" class="headerlink" title="二.类加载子系统"></a>二.类加载子系统</h1><h1 id="三-运行时数据取概述及线程"><a href="#三-运行时数据取概述及线程" class="headerlink" title="三.运行时数据取概述及线程"></a>三.运行时数据取概述及线程</h1><h1 id="四-程序计数器"><a href="#四-程序计数器" class="headerlink" title="四.程序计数器"></a>四.程序计数器</h1><h1 id="五-虚拟机栈"><a href="#五-虚拟机栈" class="headerlink" title="五.虚拟机栈"></a>五.虚拟机栈</h1><h1 id="六-本地方法接口"><a href="#六-本地方法接口" class="headerlink" title="六.本地方法接口"></a>六.本地方法接口</h1><h1 id="七-本地方法栈"><a href="#七-本地方法栈" class="headerlink" title="七.本地方法栈"></a>七.本地方法栈</h1><h1 id="八-堆"><a href="#八-堆" class="headerlink" title="八.堆"></a>八.堆</h1><h1 id="九-方法区"><a href="#九-方法区" class="headerlink" title="九. 方法区"></a>九. 方法区</h1><h1 id="十-直接内存"><a href="#十-直接内存" class="headerlink" title="十.直接内存"></a>十.直接内存</h1><h1 id="十一-执行引擎"><a href="#十一-执行引擎" class="headerlink" title="十一.执行引擎"></a>十一.执行引擎</h1><h1 id="十二-String-Table"><a href="#十二-String-Table" class="headerlink" title="十二. String  Table"></a>十二. String  Table</h1><h1 id="十三-垃圾回收概述"><a href="#十三-垃圾回收概述" class="headerlink" title="十三.垃圾回收概述"></a>十三.垃圾回收概述</h1><h1 id="十四-垃圾回收相关算法"><a href="#十四-垃圾回收相关算法" class="headerlink" title="十四. 垃圾回收相关算法"></a>十四. 垃圾回收相关算法</h1><h1 id="十五-垃圾回收相关概念"><a href="#十五-垃圾回收相关概念" class="headerlink" title="十五 垃圾回收相关概念"></a>十五 垃圾回收相关概念</h1><h1 id="十六-垃圾回收器"><a href="#十六-垃圾回收器" class="headerlink" title="十六. 垃圾回收器"></a>十六. 垃圾回收器</h1>]]></content>
      <categories>
        <category>JVM虚拟机学习</category>
      </categories>
      <tags>
        <tag>Java底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>RBAC</title>
    <url>/2021/01/17/RBAC/</url>
    <content><![CDATA[<h1 id="RBAC学习"><a href="#RBAC学习" class="headerlink" title="RBAC学习"></a>RBAC学习</h1><h2 id="一-什么是RBAC？"><a href="#一-什么是RBAC？" class="headerlink" title="一. 什么是RBAC？"></a>一. 什么是RBAC？</h2><p>RBAC(Role-Based Access Control)基于角色的访问控制。这种模型（用户-角色-权限模型）的基本概念是把许可权与角色联系在一起，用户通过充当合适角色的成员而获得该角色的许可权。一个用户拥有若干个角色，每一个角色拥有若干个权限。在这种模型中，用户与角色之间，角色与权限(功能)之间，一般都是多对多的关系。</p>
<p>RBAC重要对象：</p>
<ol>
<li><strong>用户</strong>：角色施加的主体；用户通过拥有某个或多个角色以得到对应的权限</li>
<li><strong>角色</strong>：一组权限的集合</li>
<li><strong>权限</strong>：用于限定能够访问的一个资源</li>
</ol>
<p>权限赋予给角色，而把角色又赋予用户</p>
<h2 id="二-RBAC级别"><a href="#二-RBAC级别" class="headerlink" title="二.RBAC级别"></a>二.RBAC级别</h2><h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>定义了能构成一个RBAC控制系统的最小的元素集合，<strong>RBAC0是RBAC的核心模型</strong>，其他的级别都是建立在该级别的基础上。</p>
<p>主要由四部分组成：</p>
<ol>
<li>用户</li>
<li>角色</li>
<li>许可</li>
<li>会话</li>
</ol>
<p>在RBAC之中，包含用户users(USERS)、角色roles(ROLES)、目标objects(OBS)、操作operations(OPS)、许可权permissions(PRMS)五个基本数据元素，<font color='orange'>权限被赋予角色</font>,而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的权限，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展</p>
<p><img src="C:\Users\lenovo\Desktop\y.png"></p>
<h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>引入角色之间的继承关系，进行了角色的分层，也就是说有了上下级别的关系。</p>
<p>角色之间的继承关系可以分为继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构。</p>
<p>RBAC1是对RBAC0进行了扩展，是RBAC的角色分层模型，RBAC1引入了角色继承概念，有了继承就有了上下级的包含关系。</p>
<h3 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h3><p>该模型中添加了责任分离关系</p>
<p>一些特殊的角色是不能赋予给一个用户的，比如：财务当中的会计和出纳角色不能同时赋予给一个人</p>
<h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>RBAC3包含了RBAC1和RBAC2，既提供了角色间的继承关系，又提供了责任分离关系</p>
<h1 id="三-RBAC实战案例"><a href="#三-RBAC实战案例" class="headerlink" title="三.RBAC实战案例"></a>三.RBAC实战案例</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1   需求"></a>1   需求</h2><ol>
<li>实现用户登录功能</li>
<li>使用RBAC0模型管理系统权限</li>
<li>对系统的菜单以及菜单中的链接进行管理</li>
<li>用户登录后首页根据用户角色显示该角色所对应的菜单</li>
<li>禁止用户越级访问</li>
</ol>
<h2 id="2-技术选择"><a href="#2-技术选择" class="headerlink" title="2  技术选择"></a>2  技术选择</h2><ol>
<li>框架：SpringMVC+Spring+Mybatis</li>
<li>数据库：Mysql</li>
</ol>
<h2 id="3-数据库设计"><a href="#3-数据库设计" class="headerlink" title="3  数据库设计"></a>3  数据库设计</h2><p>数据库的设计表</p>
<h2 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4 权限管理"></a>4 权限管理</h2><h3 id="1越级访问"><a href="#1越级访问" class="headerlink" title="1越级访问"></a>1越级访问</h3><p>所谓越级访问就是使用低级本的角色访问高级别的资源</p>
<p><strong>DTree</strong></p>
<p><strong>在菜单生成的过程中，所有的功能都落脚于子结点上，页面的树型菜单就很难生成，外连接可以查到孤儿数据的</strong></p>
<p><strong>权限过滤器</strong></p>
]]></content>
      <tags>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <url>/2021/01/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>markdown语法学习 &amp;&amp;  Typora工具的使用</title>
    <url>/2021/01/17/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-Typora%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>markdown使用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>为了可以让新接触算法的小白可以更快对算法有一个直观的认识，先给大家引出几个经典算法题来激发大家对算法的兴趣，毕竟不会算法的程序员不是一个好的程序员，希望大家可以对算法有一个很好的重视。要明白算法是程序的灵魂，如果不想成为代码工人，那就花时间来研究数据结构和算法，程序=数据结构+算法。数据结构是算法的基础，想学好算法。需要把数据结构学到位。</p>
<h2 id="一-引出几个经典的算法面试题"><a href="#一-引出几个经典的算法面试题" class="headerlink" title="一. 引出几个经典的算法面试题##"></a>一. 引出几个经典的算法面试题##</h2><h3 id="1-1字符串匹配问题"><a href="#1-1字符串匹配问题" class="headerlink" title="1.1字符串匹配问题"></a>1.1字符串匹配问题</h3><ul>
<li>算法：暴力匹配(简单、但是效率低)、KMP算法(部分匹配表)——面试题会用这个算法来解决</li>
<li>要求：用最快的速度来完成匹配、</li>
<li>思路是什么？</li>
</ul>
<h3 id="1-2汉诺塔游戏"><a href="#1-2汉诺塔游戏" class="headerlink" title="1.2汉诺塔游戏"></a>1.2汉诺塔游戏</h3><p>将A塔的所有圆盘移动到C塔并且规定，小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘<br><img src="https://github.com/jianier/pictureRepo/blob/master/5.png" alt="image"></p>
<h3 id="1-3八皇后问题——回溯算法的经典案例"><a href="#1-3八皇后问题——回溯算法的经典案例" class="headerlink" title="1.3八皇后问题——回溯算法的经典案例"></a>1.3八皇后问题——回溯算法的经典案例</h3><p>1)即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？<br>2)用图论的方法解出有92种<br>3)分治算法</p>
<h3 id="1-4马踏棋盘算法又称骑士周游问题"><a href="#1-4马踏棋盘算法又称骑士周游问题" class="headerlink" title="1.4马踏棋盘算法又称骑士周游问题"></a>1.4马踏棋盘算法又称骑士周游问题</h3><p>1)将马随机放在国际象棋的8×8棋盘的某个方格中。马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。<br><img src="C:\Users\lenovo\Desktop\6.png" alt="avatar"><br>2)会使用到图图的深度优化遍历算法(DFS)+贪心算法优化<br>#二. 数据结构<br>##2.1线性和非线性结构  ##</p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>2.1.1 线性结构的特点：数据元素之间存在“一对一的”线性关系<br>2.1.2 线性结构有两种不同的存储结构：<br>1）顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表种的存储元素是连续的<br>2）链式存储的线性表称为链表，链表种的存储元素“不一定是连续的”，元素节点中存放数据元素以及相邻元素的地址信息<br>2.1.3 线性结构常见的有:数组、队列、链表和栈</p>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>1）非线性结构包括：二维数组、多维数组、广义表、树结构、图结构<br>##2.2稀疏数组和队列  ##</p>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>2.2.1应用：五子棋存盘退出和续上盘 、地图<br>2.2.2概念：当一个数组种大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是：<br>1）记录数组一工有几行几列，有多少个不同的值<br>2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。<br><img src="https://github.com/jianier/pictureRepo/blob/master/7.png" alt="image"></p>
<h3 id="2-2-3-二维数组转稀疏数组的思路"><a href="#2-2-3-二维数组转稀疏数组的思路" class="headerlink" title="2.2.3 二维数组转稀疏数组的思路"></a>2.2.3 二维数组转稀疏数组的思路</h3><p>1）遍历 原始的二维数组，得到有效数据的个数sum<br>2)根据sum就可以创建稀疏数组sparseArr  int[sum+1][3]<br>3)将二维数组的有效数据存入到稀疏数组中 </p>
<h3 id="2-2-4-稀疏数组转二维数组的思路"><a href="#2-2-4-稀疏数组转二维数组的思路" class="headerlink" title="2.2.4 稀疏数组转二维数组的思路"></a>2.2.4 稀疏数组转二维数组的思路</h3><p>1）先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。比如上面的chessArr2=int[11][11]<br>2）在读取稀疏数组后几行的数据，并赋给原始的二维数组<br><img src="https://github.com/jianier/pictureRepo/blob/master/8.png" alt="image"><br>##2.3链表 ##</p>
<h3 id="2-3-1链表"><a href="#2-3-1链表" class="headerlink" title="2.3.1链表"></a>2.3.1链表</h3><h3 id="2-3-2单链表"><a href="#2-3-2单链表" class="headerlink" title="2.3.2单链表"></a>2.3.2单链表</h3><h3 id="2-3-3双向链表"><a href="#2-3-3双向链表" class="headerlink" title="2.3.3双向链表"></a>2.3.3双向链表</h3><h3 id="2-3-4单向环形链表"><a href="#2-3-4单向环形链表" class="headerlink" title="2.3.4单向环形链表"></a>2.3.4单向环形链表</h3><h2 id="2-4栈"><a href="#2-4栈" class="headerlink" title="2.4栈"></a>2.4栈</h2><h2 id="2-5前缀、中缀、后缀表达式-逆波兰表达式"><a href="#2-5前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="2.5前缀、中缀、后缀表达式(逆波兰表达式)"></a>2.5前缀、中缀、后缀表达式(逆波兰表达式)</h2><h3 id="2-5-1逆波兰计算器"><a href="#2-5-1逆波兰计算器" class="headerlink" title="2.5.1逆波兰计算器"></a>2.5.1逆波兰计算器</h3><h2 id="2-6递归"><a href="#2-6递归" class="headerlink" title="2.6递归"></a>2.6递归</h2><h3 id="2-6-1迷宫问题"><a href="#2-6-1迷宫问题" class="headerlink" title="2.6.1迷宫问题"></a>2.6.1迷宫问题</h3><h3 id="2-6-2八皇后问题-回溯算法"><a href="#2-6-2八皇后问题-回溯算法" class="headerlink" title="2.6.2八皇后问题(回溯算法)"></a>2.6.2八皇后问题(回溯算法)</h3><h2 id="2-7八大排序算法"><a href="#2-7八大排序算法" class="headerlink" title="2.7八大排序算法"></a>2.7八大排序算法</h2><h3 id="2-7-1内部-使用内存-排序栈"><a href="#2-7-1内部-使用内存-排序栈" class="headerlink" title="2.7.1内部(使用内存)排序栈"></a>2.7.1内部(使用内存)排序栈</h3><ol>
<li>插入排序：<br>1.1直接插入排序<br>1.2希尔排序</li>
<li>选择排序<br>2.1简单选择排序<br>2.2堆排序</li>
<li>交换排序<br>3.1冒泡排序<br>3.2快速排序 </li>
<li>归并排序</li>
<li>基数排序(桶排序)<h3 id="2-7-2外部-使用内存和外存结合-排序栈"><a href="#2-7-2外部-使用内存和外存结合-排序栈" class="headerlink" title="2.7.2外部(使用内存和外存结合)排序栈"></a>2.7.2外部(使用内存和外存结合)排序栈</h3><h2 id="2-8算法的时间复杂度"><a href="#2-8算法的时间复杂度" class="headerlink" title="2.8算法的时间复杂度"></a>2.8算法的时间复杂度</h2></li>
</ol>
<ul>
<li><p>常数阶  </p>
</li>
<li><p>对数阶  </p>
</li>
<li><p>线性阶  </p>
</li>
<li><p>线性对数阶  </p>
</li>
<li><p>平方阶  </p>
</li>
<li><p>立方阶  </p>
</li>
<li><p>k次方阶  </p>
</li>
<li><p>指数阶级O(2^n)<br>##2.9查找算法##</p>
</li>
</ul>
<ol>
<li>线性查找算法</li>
<li>二分查找算法</li>
<li>插值查找算法</li>
<li>斐波那契(黄金分割)算法<h2 id="2-10哈希表"><a href="#2-10哈希表" class="headerlink" title="2.10哈希表##"></a>2.10哈希表##</h2><h2 id="2-11树"><a href="#2-11树" class="headerlink" title="2.11树##"></a>2.11树##</h2></li>
<li>二叉树</li>
<li>顺序存储二叉树</li>
<li>线索化二叉树<h2 id="2-12树结构的实际应用"><a href="#2-12树结构的实际应用" class="headerlink" title="2.12树结构的实际应用##"></a>2.12树结构的实际应用##</h2></li>
</ol>
<ul>
<li>堆排序</li>
<li>赫夫曼树</li>
<li>赫夫曼编码<br>1)最佳实践-数据压缩(创建赫夫曼树)<br>2)最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)<br>3）最佳实践-数据解压(使用赫夫曼编码)<br>4）最佳实践-文件压缩<br>5）最佳实践-文件解压(文件恢复)  </li>
<li>二叉排序树</li>
<li>平衡二叉树(AVL树)</li>
<li>多路查找树<br>二叉树与B树<br>2-3树<br>B树、B+树和B*树<br>##2.12图##</li>
</ul>
<ol>
<li>图的创建和深度优先搜索算法</li>
</ol>
<h1 id="三-算法"><a href="#三-算法" class="headerlink" title="三.算法"></a>三.算法</h1><h2 id="3-1二分查找算法-非递归"><a href="#3-1二分查找算法-非递归" class="headerlink" title="3.1二分查找算法(非递归)##"></a>3.1二分查找算法(非递归)##</h2><h2 id="3-2分治算法"><a href="#3-2分治算法" class="headerlink" title="3.2分治算法##"></a>3.2分治算法##</h2><p>汉诺塔</p>
<h2 id="3-3动态规划算法"><a href="#3-3动态规划算法" class="headerlink" title="3.3动态规划算法##"></a>3.3动态规划算法##</h2><p>0-1背包问题</p>
<h2 id="3-4KMP算法"><a href="#3-4KMP算法" class="headerlink" title="3.4KMP算法##"></a>3.4KMP算法##</h2><h2 id="3-5贪心算法"><a href="#3-5贪心算法" class="headerlink" title="3.5贪心算法##"></a>3.5贪心算法##</h2><p>集合覆盖问题</p>
<h2 id="3-6普利姆算法"><a href="#3-6普利姆算法" class="headerlink" title="3.6普利姆算法##"></a>3.6普利姆算法##</h2><p>修路问题</p>
<h2 id="3-7克鲁斯卡尔算法"><a href="#3-7克鲁斯卡尔算法" class="headerlink" title="3.7克鲁斯卡尔算法##"></a>3.7克鲁斯卡尔算法##</h2><p>公交站问题</p>
<h2 id="3-8迪杰斯特拉算法-Dijksta"><a href="#3-8迪杰斯特拉算法-Dijksta" class="headerlink" title="3.8迪杰斯特拉算法(Dijksta)##"></a>3.8迪杰斯特拉算法(Dijksta)##</h2><p>最短路径算法</p>
<h2 id="3-9弗洛伊德算法-Floyd"><a href="#3-9弗洛伊德算法-Floyd" class="headerlink" title="3.9弗洛伊德算法(Floyd)##"></a>3.9弗洛伊德算法(Floyd)##</h2><p>弗洛伊德算法vs迪杰斯特拉算法</p>
<h2 id="3-10马踏棋盘算法"><a href="#3-10马踏棋盘算法" class="headerlink" title="3.10马踏棋盘算法##"></a>3.10马踏棋盘算法##</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro</title>
    <url>/2021/01/19/Shiro/</url>
    <content><![CDATA[<h1 id="Shiro的简介"><a href="#Shiro的简介" class="headerlink" title="Shiro的简介"></a>Shiro的简介</h1><h2 id="一-为什么学习Shiro"><a href="#一-为什么学习Shiro" class="headerlink" title="一.为什么学习Shiro?"></a>一.<strong>为什么学习Shiro?</strong></h2><p><strong>A、目前使用遇到的问题？</strong></p>
<ol start="2">
<li>目前学习 的写的操作代码整体不太安全</li>
<li>使用RBAC进行角色访问控制的时候，代码书写起来相对比较麻烦</li>
</ol>
<p><strong>B、解决方案</strong></p>
<ol>
<li><strong>Spring Security  安全框架</strong>   缺点：基于Spring之上的，局限性比较大</li>
<li><strong>Shiro</strong>    可以在javaEE  javaSE  分布式项目上</li>
</ol>
<p><strong>C、什么是Shiro?</strong></p>
<p>Apache Shiro 是一个强大而灵活的开源<font color='red'>安全</font>框架，它干净利落地处理<font color='red'>身份认证</font>，<font color='orange'>授权</font>，<font color='cornflowerblue'>企业会话管理</font>和<font color='red'>加密</font>。</p>
<h2 id="二-Shiro中的体系组成"><a href="#二-Shiro中的体系组成" class="headerlink" title="二. Shiro中的体系组成"></a>二. Shiro中的体系组成</h2><p><img src="C:\Users\lenovo\Desktop\z.png"></p>
<p>Shiro的开发团队成为“<strong>应用程序的四大基石”</strong>——身份验证、授权、会话管理和加密作为其目标。</p>
<ul>
<li><strong>Authentication</strong>：<strong>身份验证</strong>/<strong>认证</strong>–有时也简称为“<strong>登录</strong>”，这是一个证明用户是他们所说的他们是谁的行为。</li>
<li><strong>Authorization</strong>：<strong>授权</strong>–赋予角色不同的菜单功能，访问控制的过程。</li>
<li><strong>Session Management</strong>：<strong>管理登录用户的信息</strong></li>
<li><strong>Cryptography</strong>：<strong>加密技术</strong> 比如MD5加密算法等</li>
</ul>
<p>也提供了<strong>额外的功能</strong>来支持和加强在不同环境下所关注的方面：</p>
<ul>
<li>**Web Support:**Shiro对Web项目进行的支持</li>
<li>**Caching:**缓存  可以安全快速的操作</li>
<li><strong>Concurrency</strong>：支持并发多线程的处理</li>
<li>**Testing:**测试</li>
<li>**”Run As”**：可以实现在一个用户允许的前提下，使用另一个用户访问</li>
<li>**”Remember Me”**：记住我</li>
</ul>
<h2 id="三-Shiro的架构"><a href="#三-Shiro的架构" class="headerlink" title="三. Shiro的架构"></a>三. Shiro的架构</h2><p><img src="C:\Users\lenovo\Desktop\w.png"></p>
<ul>
<li><strong><font color='red'>Subject</font></strong>(org.apache.shiro.subject.Subject)<br>当前与软件进行交互的实体（<font color='red'>用户</font>，<font color='orange'>第三方服务</font>，<font color='cornflowerblue'>cron job</font>，等等）的安全特定“视图”。</li>
<li><strong><font color='red'>SecurityManager</font></strong>(org.apache.shiro.mgt.SecurityManager)<br>如上所述，SecurityManager 是<font color='red'> Shiro 架构的心脏</font>。它基本上是一个“保护伞”对象，协调其管理的组件以确保<br>它们能够一起顺利的工作。它还管理每个应用程序用户的 Shiro 的视图，因此它知道如何执行每个用户的安全<br>操作。类似于SpringMVC中的入口Servlet即DispatchServlet</li>
<li><strong><font color='red'>Realms</font></strong>(org.apache.shiro.realm.Realm)<br>如上所述，Realms 在 Shiro 和你的应用程序的安全数据之间担当**<font color='red'>“桥梁”或“连接器”</font><strong>。当它实际上与安全<br>相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro 从一个或多个为应用<br>程序配置的 Realm 中寻找许多这样的东西。你可以按你的需要配置多个 Realm（通常</strong>一个数据源一个 Realm**），<br>且 Shiro 将为身份验证和授权对它们进行必要的协调。</li>
</ul>
<h2 id="四-使用Shiro实现登录的操作"><a href="#四-使用Shiro实现登录的操作" class="headerlink" title="四. 使用Shiro实现登录的操作"></a>四. 使用Shiro实现登录的操作</h2><p>第一步：导包</p>
<p>第二步：书写shiro.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zs=<span class="number">123</span></span><br><span class="line">sxt=root</span><br></pre></td></tr></table></figure>
<p>第三步：<strong>书写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中（相当于数据源）的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="五-Shiro验证时异常分析"><a href="#五-Shiro验证时异常分析" class="headerlink" title="五. Shiro验证时异常分析"></a>五. Shiro验证时异常分析</h2><p><strong>DisabledAccountException</strong><br>账户失效异常<br><strong>ConcurrentAccessException</strong><br>竞争次数过多<br><strong>ExcessiveAttemptsException</strong><br>尝试次数过多<br><strong>UnknownAccountException</strong><br>用户名不正确<br><strong>IncorrectCredentialsException</strong><br>凭证（密码）不正确<br><strong>ExpiredCredentialsException</strong><br>凭证过期<br>使用 shiro 做异常处理的时候，尽量把<strong>异常信息表示的婉转一点</strong>，这样有助于提升代码的安全性</p>
<h2 id="六-Shiro的认证流程"><a href="#六-Shiro的认证流程" class="headerlink" title="六. Shiro的认证流程"></a>六. Shiro的认证流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、通过 shiro 相关的 API 创建了 SecurityManager 以及获得subject 实例</span><br><span class="line"><span class="number">2</span>、封装了 token 信息</span><br><span class="line"><span class="number">3</span>、详细描述</span><br><span class="line">通过 subject.login(token)进行用户认证</span><br><span class="line">Subject 接受 token 信息 ，通过 DelegatingSubject将 token 委托给 securityManager 完成认证</span><br><span class="line">securityManager 通过使用 DefaultSecurityManager完成相关功能,</span><br><span class="line">由 DefaultSecurityManager 中的 login 方法完成对应的认证,在 login 中调用了AuthenticatingSecurityManager中的authenticate 方法完成认证,使用其中的doAuthenticate获得realms信息,如果是单个直接进行比较，判断是否成功，如果是多个 raalm 需要使用验证策略完成对应的认证工作</span><br></pre></td></tr></table></figure>
<h2 id="七-Shiro的认证策略"><a href="#七-Shiro的认证策略" class="headerlink" title="七. Shiro的认证策略"></a>七. Shiro的认证策略</h2><p>定了如果有多个数据源的时候应该如何操作</p>
<ol>
<li><strong>AtLeastOneSuccessfulStrategy</strong><br>如果一个（或更多）Realm 验证成功，则整体的尝试被认为是成功的。<br>如果没有一个验证成功，<br>则整体尝试失败 类似于 java 中的 &amp;</li>
<li><strong>FirstSuccessfulStrategy</strong><br>只有第一个成功地验证的 Realm 返回的信息将被使用。所有进一步的<br>Realm 将被忽略。如果没有一个验证成功，则整体尝试失败。<br>类似于 java 中的 &amp;&amp;</li>
<li><strong>AllSucessfulStrategy</strong><br>为了整体的尝试成功，所有配置的 Realm 必须验证成功。如果没有一个验<br>证成功，则整体尝试失败</li>
</ol>
<h2 id="八-自定义Realm"><a href="#八-自定义Realm" class="headerlink" title="八. 自定义Realm"></a>八. 自定义Realm</h2><ol>
<li><p>为什么使用自定义Realm？</p>
<p>我们使用JDBCRealm的时候发现，shiro的底层自己封装了数据库表的名称和字段的名称，这样就造成了使用起来非常的不方便。</p>
</li>
<li><p>解决方案</p>
<p>自定义Realm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义realm：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">       <span class="comment">//authenticationToken封装了用户的信息</span></span><br><span class="line">        <span class="comment">//authenticationToken.getPrincipal()得到的是用户名比如：root</span></span><br><span class="line">        System.out.println(authenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/yjy&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ps = conn.prepareStatement(<span class="string">&quot;select pwd from admin where uname=? &quot;</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, (String) authenticationToken.getPrincipal());</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息  密码作比较</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro-jdbc2.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="九-加密算法"><a href="#九-加密算法" class="headerlink" title="九. 加密算法"></a>九. 加密算法</h2><p><strong>散列算法(算法加密)</strong></p>
<ol>
<li>在身份认证的过程中往往都会涉及到加密,如果不加密,这个时<br> 候信息就会非常的不安全,shiro 中提供的算法比较多 如 MD5、SHA 等<br> 使用 <strong>MD5</strong> 进行 ‘’1111 加密<br> b59c67bf196a4758191e42f76670ceba  单纯的进行MD5加密的话，可以通过在网上通过一张表解密，所以还要结合加盐操作进行加密<br> 进行<strong>加盐操作</strong><br> 1111+姓名=</li>
<li> 实现的案例</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用MD5加密</span></span><br><span class="line">        Md5Hash md5 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加盐</span></span><br><span class="line">        Md5Hash md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line">        <span class="comment">//迭代的次数(再次加盐)  迭代太多，效率会有影响</span></span><br><span class="line">        md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义Realm   加盐之后和之前自定义Realm的不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息作比较</span></span><br><span class="line">                <span class="comment">//加盐处理：ByteSource.Util.bytes(&quot;sxt&quot;)</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), ByteSource.Util.bytes(<span class="string">&quot;sxt&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>shiro.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#设置securityManager中的realm</span><br><span class="line">credentialMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">#设置加密类型</span><br><span class="line">credentialMatcher.hashAlgorithmName=md5</span><br><span class="line">#设置迭代次数</span><br><span class="line">credentialMatcher.hashIteration=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 因为自定义的UserRealm继承了AuthorizingRealm ，所以先设置AuthorizingRealm 这个里面的credentialMatcher的属性，然后再赋给UserRealm即可</span><br><span class="line">userRealm=com.bjsxt.shiro03.UserRealm</span><br><span class="line">userRealm.credentialMatcher=$credentialMatcher</span><br><span class="line">securityManager.realms=$userRealm</span><br></pre></td></tr></table></figure>
<h2 id="十-授权"><a href="#十-授权" class="headerlink" title="十. 授权"></a>十. 授权</h2><ol>
<li>授权:给身份认证通过的任授予某些资源的访问权限</li>
<li>权限的粒度： 粗粒度 细粒度<br><strong>粗粒度</strong><br>User 具有 CRUD 的操作 通常指的是表的操作<br><strong>细粒度</strong><br>只允许查询 id=1 的用户 使用业务代码实现<br><strong>Shiro 的授权是粗粒度</strong><br><strong>角色</strong>：角色就是权限的集合</li>
<li>Shiro 中代码的实现<br>详细见代码<br>Shiro 中的授权检查的 3 种方式</li>
</ol>
<ul>
<li><p> <strong>编程式</strong></p>
</li>
<li><p><strong>注解式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.annotation.RequiresRoles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*注解式授权*/</span></span><br><span class="line">    <span class="meta">@RequiresRoles(&quot;管理员&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>标签配置</strong>  用在web项目里面 jsp页面</p>
<figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml">&lt;%</span><span class="ruby">@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml">&lt;%</span><span class="ruby"><span class="variable">@taglib</span> prefix=<span class="string">&quot;shiro&quot;</span> uri=<span class="string">&quot;http://shiro.apache.org/tags&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">&lt;%-</span><span class="ruby">-标签式授权-</span><span class="xml">-%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>添加操作<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>授权详细代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;zs&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权的查询</span></span><br><span class="line">        <span class="comment">//基于角色的授权   查询单个subject.hasRole()</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = subject.hasRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个角色   subject.hasRoles()</span></span><br><span class="line">        <span class="keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (Boolean b : booleans) &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以使用checkRole判断指定用户是否具有对应角色</span></span><br><span class="line">        <span class="comment">//如果没有指定角色就会抛出异常UnauthorizedException   有的话就不报异常</span></span><br><span class="line">        subject.checkRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个角色</span></span><br><span class="line">        subject.checkRoles(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基于资源的授权  看这个用户下有没有对应的菜单</span></span><br><span class="line">        <span class="keyword">boolean</span> flag2 = subject.isPermitted(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        System.out.println(flag2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个资源</span></span><br><span class="line">        <span class="keyword">boolean</span> permittedAll = subject.isPermittedAll(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;oo&quot;</span>, <span class="string">&quot;ii&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过checkPermission进行判断指定用户下是否有指定的资源</span></span><br><span class="line">        <span class="comment">//如果没有就会抛出异常</span></span><br><span class="line">        subject.checkPermission(<span class="string">&quot;uu&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个</span></span><br><span class="line">        subject.checkPermissions(<span class="string">&quot;uu&quot;</span>, <span class="string">&quot;oo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>shio.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#指定具体的用户</span><br><span class="line">[users]</span><br><span class="line">#role给用户赋予角色  授权</span><br><span class="line">zs=<span class="number">123</span>,role1,role2</span><br><span class="line">sxt=root</span><br><span class="line"></span><br><span class="line">#角色的定义</span><br><span class="line">[roles]</span><br><span class="line">role1=add,update,delete</span><br><span class="line">role2=find</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#给对象中的属性赋值</span><br><span class="line">[main]</span><br></pre></td></tr></table></figure>
<p>  <strong>自定义 Realm  实现授权</strong><br>      我们仅仅通过配置文件指定授权是非常的不灵活的，在实际的应用中我们是将用户的信息和合权限信息保存到数据库中，我们是从数据库中获得用户的信息 ，使用 JDBCRealm 进行授权 。使用 JDBCRealm 操作的时候也不是很灵活。所以我们一般使用自定义 Realm 实现授权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义realm完成授权：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户登陆名</span></span><br><span class="line">        String username = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">        <span class="comment">//获得username，然后去数据库查询这个用户对应的角色，再根据角色查询出指定角色下对应的菜单</span></span><br><span class="line">        <span class="comment">//返回给指定角色下的所有菜单---List集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟数据库查询到该用户所对应的菜单</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;updateUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;deleteUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;addUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">            simpleAuthorizationInfo.addStringPermission(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shiro的基础知识</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
</search>
