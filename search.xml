<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Shiro</title>
    <url>/2021/01/17/Shiro/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>RBAC</title>
    <url>/2021/01/17/RBAC/</url>
    <content><![CDATA[<h1 id="RBAC学习"><a href="#RBAC学习" class="headerlink" title="RBAC学习"></a>RBAC学习</h1><h2 id="一-什么是RBAC？"><a href="#一-什么是RBAC？" class="headerlink" title="一. 什么是RBAC？"></a>一. 什么是RBAC？</h2><p>RBAC(Role-Based Access Control)基于角色的访问控制</p>
<p>RBAC认为权限的过程可以抽象概括为：</p>
<p>判断【who是否对What进行how的访问操作(Operator)】</p>
<p>Who：权限的拥有者或者主体</p>
<p>How：具体的权限</p>
<p>Operator：操作。表明对what的how操作。也就是Privilege+Resource</p>
<p>Role：角色，一定数量的权限的集合。权限分配的单位与载体，目的是隔离User与Privilege的逻辑关系</p>
<h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>定义了能构成一个RBAC控制系统的最小的元素集合</p>
<p>在RBAC之中，包含用户users(USERS)、角色roles(ROLES)、目标objects(OBS)、操作operations(OPS)、许可权permissions(PRMS)五个基本数据元素，<font color='orange'>权限被赋予角色</font>,而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的权限，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展</p>
<h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>引入角色之间的继承关系</p>
<p>角色之间的继承关系可以分为继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构。</p>
<p>RBAC1是对RBAC0进行了扩展，是RBAC的角色分层模型，RBAC1引入了角色继承概念，有了继承就有了上下级的包含关系。</p>
<h3 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h3><p>该模型中添加了责任分离关系</p>
<p>一些特殊的角色是不能赋予给一个用户的，比如：财务当中的会计和出纳角色不能同时赋予给一个人</p>
<h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>RBAC3包含了RBAC1和RBAC2，既提供了角色间的继承关系，又提供了责任分离关系</p>
<h1 id="二-RBAC实战案例"><a href="#二-RBAC实战案例" class="headerlink" title="二.RBAC实战案例"></a>二.RBAC实战案例</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1   需求"></a>1   需求</h2><ol>
<li>实现用户登录功能</li>
<li>使用RBAC0模型管理系统权限</li>
<li>对系统的菜单以及菜单中的链接进行管理</li>
<li>用户登录后首页根据用户角色显示该角色所对应的菜单</li>
<li>禁止用户越级访问</li>
</ol>
<h2 id="2-技术选择"><a href="#2-技术选择" class="headerlink" title="2  技术选择"></a>2  技术选择</h2><ol>
<li>框架：SpringMVC+Spring+Mybatis</li>
<li>数据库：Mysql</li>
</ol>
<h2 id="3-数据库设计"><a href="#3-数据库设计" class="headerlink" title="3  数据库设计"></a>3  数据库设计</h2><p>数据库的设计表</p>
]]></content>
      <tags>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机学习</title>
    <url>/2021/01/17/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li>JVM的整体结构  </li>
<li>Java代码执行流程  </li>
<li>JVM的架构模型    </li>
<li>JVM的生命周期   </li>
<li>JVM的发展历程  </li>
</ul>
<p>开发人员如何看待上层框架？<br>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。<br>如果我们把核心类库的API比作数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。  </p>
<p>为什么要学习JVM？<br>1）面试的需要(BATJ 京东、TMD 今日头条美团 滴滴、PKQ拼多多 快手趣多多等面试都爱问)<br>2）中高级程序员必备技能：项目管理、调优的需要<br>3）追求极客的精神<br>比如：垃圾回收算法、JIT即时编译器、底层原理 </p>
<h1 id="一-JVM与Java体系结构"><a href="#一-JVM与Java体系结构" class="headerlink" title="一.JVM与Java体系结构"></a>一.JVM与Java体系结构</h1><p>Java的基本概念</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底如何使用何种编程语言编写的 ，它$\textcolor{Magenta}{只关心“字节码”文件}$，也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h1 id="二-类加载子系统"><a href="#二-类加载子系统" class="headerlink" title="二.类加载子系统"></a>二.类加载子系统</h1><h1 id="三-运行时数据取概述及线程"><a href="#三-运行时数据取概述及线程" class="headerlink" title="三.运行时数据取概述及线程"></a>三.运行时数据取概述及线程</h1><h1 id="四-程序计数器"><a href="#四-程序计数器" class="headerlink" title="四.程序计数器"></a>四.程序计数器</h1><h1 id="五-虚拟机栈"><a href="#五-虚拟机栈" class="headerlink" title="五.虚拟机栈"></a>五.虚拟机栈</h1><h1 id="六-本地方法接口"><a href="#六-本地方法接口" class="headerlink" title="六.本地方法接口"></a>六.本地方法接口</h1><h1 id="七-本地方法栈"><a href="#七-本地方法栈" class="headerlink" title="七.本地方法栈"></a>七.本地方法栈</h1><h1 id="八-堆"><a href="#八-堆" class="headerlink" title="八.堆"></a>八.堆</h1><h1 id="九-方法区"><a href="#九-方法区" class="headerlink" title="九. 方法区"></a>九. 方法区</h1><h1 id="十-直接内存"><a href="#十-直接内存" class="headerlink" title="十.直接内存"></a>十.直接内存</h1><h1 id="十一-执行引擎"><a href="#十一-执行引擎" class="headerlink" title="十一.执行引擎"></a>十一.执行引擎</h1><h1 id="十二-String-Table"><a href="#十二-String-Table" class="headerlink" title="十二. String  Table"></a>十二. String  Table</h1><h1 id="十三-垃圾回收概述"><a href="#十三-垃圾回收概述" class="headerlink" title="十三.垃圾回收概述"></a>十三.垃圾回收概述</h1><h1 id="十四-垃圾回收相关算法"><a href="#十四-垃圾回收相关算法" class="headerlink" title="十四. 垃圾回收相关算法"></a>十四. 垃圾回收相关算法</h1><h1 id="十五-垃圾回收相关概念"><a href="#十五-垃圾回收相关概念" class="headerlink" title="十五 垃圾回收相关概念"></a>十五 垃圾回收相关概念</h1><h1 id="十六-垃圾回收器"><a href="#十六-垃圾回收器" class="headerlink" title="十六. 垃圾回收器"></a>十六. 垃圾回收器</h1>]]></content>
      <categories>
        <category>JVM虚拟机学习</category>
      </categories>
      <tags>
        <tag>Java底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法学习 &amp;&amp;  Typora工具的使用</title>
    <url>/2021/01/17/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-Typora%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>markdown使用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <url>/2021/01/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>为了可以让新接触算法的小白可以更快对算法有一个直观的认识，先给大家引出几个经典算法题来激发大家对算法的兴趣，毕竟不会算法的程序员不是一个好的程序员，希望大家可以对算法有一个很好的重视。要明白算法是程序的灵魂，如果不想成为代码工人，那就花时间来研究数据结构和算法，程序=数据结构+算法。数据结构是算法的基础，想学好算法。需要把数据结构学到位。</p>
<h2 id="一-引出几个经典的算法面试题"><a href="#一-引出几个经典的算法面试题" class="headerlink" title="一. 引出几个经典的算法面试题##"></a>一. 引出几个经典的算法面试题##</h2><h3 id="1-1字符串匹配问题"><a href="#1-1字符串匹配问题" class="headerlink" title="1.1字符串匹配问题"></a>1.1字符串匹配问题</h3><ul>
<li>算法：暴力匹配(简单、但是效率低)、KMP算法(部分匹配表)——面试题会用这个算法来解决</li>
<li>要求：用最快的速度来完成匹配、</li>
<li>思路是什么？</li>
</ul>
<h3 id="1-2汉诺塔游戏"><a href="#1-2汉诺塔游戏" class="headerlink" title="1.2汉诺塔游戏"></a>1.2汉诺塔游戏</h3><p>将A塔的所有圆盘移动到C塔并且规定，小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘<br><img src="https://github.com/jianier/pictureRepo/blob/master/5.png" alt="image"></p>
<h3 id="1-3八皇后问题——回溯算法的经典案例"><a href="#1-3八皇后问题——回溯算法的经典案例" class="headerlink" title="1.3八皇后问题——回溯算法的经典案例"></a>1.3八皇后问题——回溯算法的经典案例</h3><p>1)即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？<br>2)用图论的方法解出有92种<br>3)分治算法</p>
<h3 id="1-4马踏棋盘算法又称骑士周游问题"><a href="#1-4马踏棋盘算法又称骑士周游问题" class="headerlink" title="1.4马踏棋盘算法又称骑士周游问题"></a>1.4马踏棋盘算法又称骑士周游问题</h3><p>1)将马随机放在国际象棋的8×8棋盘的某个方格中。马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。<br><img src="C:\Users\lenovo\Desktop\6.png" alt="avatar"><br>2)会使用到图图的深度优化遍历算法(DFS)+贪心算法优化<br>#二. 数据结构<br>##2.1线性和非线性结构  ##</p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>2.1.1 线性结构的特点：数据元素之间存在“一对一的”线性关系<br>2.1.2 线性结构有两种不同的存储结构：<br>1）顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表种的存储元素是连续的<br>2）链式存储的线性表称为链表，链表种的存储元素“不一定是连续的”，元素节点中存放数据元素以及相邻元素的地址信息<br>2.1.3 线性结构常见的有:数组、队列、链表和栈</p>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>1）非线性结构包括：二维数组、多维数组、广义表、树结构、图结构<br>##2.2稀疏数组和队列  ##</p>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>2.2.1应用：五子棋存盘退出和续上盘 、地图<br>2.2.2概念：当一个数组种大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是：<br>1）记录数组一工有几行几列，有多少个不同的值<br>2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。<br><img src="https://github.com/jianier/pictureRepo/blob/master/7.png" alt="image"></p>
<h3 id="2-2-3-二维数组转稀疏数组的思路"><a href="#2-2-3-二维数组转稀疏数组的思路" class="headerlink" title="2.2.3 二维数组转稀疏数组的思路"></a>2.2.3 二维数组转稀疏数组的思路</h3><p>1）遍历 原始的二维数组，得到有效数据的个数sum<br>2)根据sum就可以创建稀疏数组sparseArr  int[sum+1][3]<br>3)将二维数组的有效数据存入到稀疏数组中 </p>
<h3 id="2-2-4-稀疏数组转二维数组的思路"><a href="#2-2-4-稀疏数组转二维数组的思路" class="headerlink" title="2.2.4 稀疏数组转二维数组的思路"></a>2.2.4 稀疏数组转二维数组的思路</h3><p>1）先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。比如上面的chessArr2=int[11][11]<br>2）在读取稀疏数组后几行的数据，并赋给原始的二维数组<br><img src="https://github.com/jianier/pictureRepo/blob/master/8.png" alt="image"><br>##2.3链表 ##</p>
<h3 id="2-3-1链表"><a href="#2-3-1链表" class="headerlink" title="2.3.1链表"></a>2.3.1链表</h3><h3 id="2-3-2单链表"><a href="#2-3-2单链表" class="headerlink" title="2.3.2单链表"></a>2.3.2单链表</h3><h3 id="2-3-3双向链表"><a href="#2-3-3双向链表" class="headerlink" title="2.3.3双向链表"></a>2.3.3双向链表</h3><h3 id="2-3-4单向环形链表"><a href="#2-3-4单向环形链表" class="headerlink" title="2.3.4单向环形链表"></a>2.3.4单向环形链表</h3><h2 id="2-4栈"><a href="#2-4栈" class="headerlink" title="2.4栈"></a>2.4栈</h2><h2 id="2-5前缀、中缀、后缀表达式-逆波兰表达式"><a href="#2-5前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="2.5前缀、中缀、后缀表达式(逆波兰表达式)"></a>2.5前缀、中缀、后缀表达式(逆波兰表达式)</h2><h3 id="2-5-1逆波兰计算器"><a href="#2-5-1逆波兰计算器" class="headerlink" title="2.5.1逆波兰计算器"></a>2.5.1逆波兰计算器</h3><h2 id="2-6递归"><a href="#2-6递归" class="headerlink" title="2.6递归"></a>2.6递归</h2><h3 id="2-6-1迷宫问题"><a href="#2-6-1迷宫问题" class="headerlink" title="2.6.1迷宫问题"></a>2.6.1迷宫问题</h3><h3 id="2-6-2八皇后问题-回溯算法"><a href="#2-6-2八皇后问题-回溯算法" class="headerlink" title="2.6.2八皇后问题(回溯算法)"></a>2.6.2八皇后问题(回溯算法)</h3><h2 id="2-7八大排序算法"><a href="#2-7八大排序算法" class="headerlink" title="2.7八大排序算法"></a>2.7八大排序算法</h2><h3 id="2-7-1内部-使用内存-排序栈"><a href="#2-7-1内部-使用内存-排序栈" class="headerlink" title="2.7.1内部(使用内存)排序栈"></a>2.7.1内部(使用内存)排序栈</h3><ol>
<li>插入排序：<br>1.1直接插入排序<br>1.2希尔排序</li>
<li>选择排序<br>2.1简单选择排序<br>2.2堆排序</li>
<li>交换排序<br>3.1冒泡排序<br>3.2快速排序 </li>
<li>归并排序</li>
<li>基数排序(桶排序)<h3 id="2-7-2外部-使用内存和外存结合-排序栈"><a href="#2-7-2外部-使用内存和外存结合-排序栈" class="headerlink" title="2.7.2外部(使用内存和外存结合)排序栈"></a>2.7.2外部(使用内存和外存结合)排序栈</h3><h2 id="2-8算法的时间复杂度"><a href="#2-8算法的时间复杂度" class="headerlink" title="2.8算法的时间复杂度"></a>2.8算法的时间复杂度</h2></li>
</ol>
<ul>
<li><p>常数阶  </p>
</li>
<li><p>对数阶  </p>
</li>
<li><p>线性阶  </p>
</li>
<li><p>线性对数阶  </p>
</li>
<li><p>平方阶  </p>
</li>
<li><p>立方阶  </p>
</li>
<li><p>k次方阶  </p>
</li>
<li><p>指数阶级O(2^n)<br>##2.9查找算法##</p>
</li>
</ul>
<ol>
<li>线性查找算法</li>
<li>二分查找算法</li>
<li>插值查找算法</li>
<li>斐波那契(黄金分割)算法<h2 id="2-10哈希表"><a href="#2-10哈希表" class="headerlink" title="2.10哈希表##"></a>2.10哈希表##</h2><h2 id="2-11树"><a href="#2-11树" class="headerlink" title="2.11树##"></a>2.11树##</h2></li>
<li>二叉树</li>
<li>顺序存储二叉树</li>
<li>线索化二叉树<h2 id="2-12树结构的实际应用"><a href="#2-12树结构的实际应用" class="headerlink" title="2.12树结构的实际应用##"></a>2.12树结构的实际应用##</h2></li>
</ol>
<ul>
<li>堆排序</li>
<li>赫夫曼树</li>
<li>赫夫曼编码<br>1)最佳实践-数据压缩(创建赫夫曼树)<br>2)最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)<br>3）最佳实践-数据解压(使用赫夫曼编码)<br>4）最佳实践-文件压缩<br>5）最佳实践-文件解压(文件恢复)  </li>
<li>二叉排序树</li>
<li>平衡二叉树(AVL树)</li>
<li>多路查找树<br>二叉树与B树<br>2-3树<br>B树、B+树和B*树<br>##2.12图##</li>
</ul>
<ol>
<li>图的创建和深度优先搜索算法</li>
</ol>
<h1 id="三-算法"><a href="#三-算法" class="headerlink" title="三.算法"></a>三.算法</h1><h2 id="3-1二分查找算法-非递归"><a href="#3-1二分查找算法-非递归" class="headerlink" title="3.1二分查找算法(非递归)##"></a>3.1二分查找算法(非递归)##</h2><h2 id="3-2分治算法"><a href="#3-2分治算法" class="headerlink" title="3.2分治算法##"></a>3.2分治算法##</h2><p>汉诺塔</p>
<h2 id="3-3动态规划算法"><a href="#3-3动态规划算法" class="headerlink" title="3.3动态规划算法##"></a>3.3动态规划算法##</h2><p>0-1背包问题</p>
<h2 id="3-4KMP算法"><a href="#3-4KMP算法" class="headerlink" title="3.4KMP算法##"></a>3.4KMP算法##</h2><h2 id="3-5贪心算法"><a href="#3-5贪心算法" class="headerlink" title="3.5贪心算法##"></a>3.5贪心算法##</h2><p>集合覆盖问题</p>
<h2 id="3-6普利姆算法"><a href="#3-6普利姆算法" class="headerlink" title="3.6普利姆算法##"></a>3.6普利姆算法##</h2><p>修路问题</p>
<h2 id="3-7克鲁斯卡尔算法"><a href="#3-7克鲁斯卡尔算法" class="headerlink" title="3.7克鲁斯卡尔算法##"></a>3.7克鲁斯卡尔算法##</h2><p>公交站问题</p>
<h2 id="3-8迪杰斯特拉算法-Dijksta"><a href="#3-8迪杰斯特拉算法-Dijksta" class="headerlink" title="3.8迪杰斯特拉算法(Dijksta)##"></a>3.8迪杰斯特拉算法(Dijksta)##</h2><p>最短路径算法</p>
<h2 id="3-9弗洛伊德算法-Floyd"><a href="#3-9弗洛伊德算法-Floyd" class="headerlink" title="3.9弗洛伊德算法(Floyd)##"></a>3.9弗洛伊德算法(Floyd)##</h2><p>弗洛伊德算法vs迪杰斯特拉算法</p>
<h2 id="3-10马踏棋盘算法"><a href="#3-10马踏棋盘算法" class="headerlink" title="3.10马踏棋盘算法##"></a>3.10马踏棋盘算法##</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
