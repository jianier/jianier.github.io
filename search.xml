<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM虚拟机学习</title>
    <url>/2021/01/17/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li>JVM的整体结构  </li>
<li>Java代码执行流程  </li>
<li>JVM的架构模型    </li>
<li>JVM的生命周期   </li>
<li>JVM的发展历程  </li>
</ul>
<p>开发人员如何看待上层框架？<br>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。<br>如果我们把核心类库的API比作数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。  </p>
<p>为什么要学习JVM？<br>1）面试的需要(BATJ 京东、TMD 今日头条美团 滴滴、PKQ拼多多 快手趣多多等面试都爱问)<br>2）中高级程序员必备技能：项目管理、调优的需要<br>3）追求极客的精神<br>比如：垃圾回收算法、JIT即时编译器、底层原理 </p>
<h1 id="一-JVM与Java体系结构"><a href="#一-JVM与Java体系结构" class="headerlink" title="一.JVM与Java体系结构"></a>一.JVM与Java体系结构</h1><p>Java的基本概念</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底如何使用何种编程语言编写的 ，它$\textcolor{Magenta}{只关心“字节码”文件}$，也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h1 id="二-类加载子系统"><a href="#二-类加载子系统" class="headerlink" title="二.类加载子系统"></a>二.类加载子系统</h1><h1 id="三-运行时数据取概述及线程"><a href="#三-运行时数据取概述及线程" class="headerlink" title="三.运行时数据取概述及线程"></a>三.运行时数据取概述及线程</h1><h1 id="四-程序计数器"><a href="#四-程序计数器" class="headerlink" title="四.程序计数器"></a>四.程序计数器</h1><h1 id="五-虚拟机栈"><a href="#五-虚拟机栈" class="headerlink" title="五.虚拟机栈"></a>五.虚拟机栈</h1><h1 id="六-本地方法接口"><a href="#六-本地方法接口" class="headerlink" title="六.本地方法接口"></a>六.本地方法接口</h1><h1 id="七-本地方法栈"><a href="#七-本地方法栈" class="headerlink" title="七.本地方法栈"></a>七.本地方法栈</h1><h1 id="八-堆"><a href="#八-堆" class="headerlink" title="八.堆"></a>八.堆</h1><h1 id="九-方法区"><a href="#九-方法区" class="headerlink" title="九. 方法区"></a>九. 方法区</h1><h1 id="十-直接内存"><a href="#十-直接内存" class="headerlink" title="十.直接内存"></a>十.直接内存</h1><h1 id="十一-执行引擎"><a href="#十一-执行引擎" class="headerlink" title="十一.执行引擎"></a>十一.执行引擎</h1><h1 id="十二-String-Table"><a href="#十二-String-Table" class="headerlink" title="十二. String  Table"></a>十二. String  Table</h1><h1 id="十三-垃圾回收概述"><a href="#十三-垃圾回收概述" class="headerlink" title="十三.垃圾回收概述"></a>十三.垃圾回收概述</h1><h1 id="十四-垃圾回收相关算法"><a href="#十四-垃圾回收相关算法" class="headerlink" title="十四. 垃圾回收相关算法"></a>十四. 垃圾回收相关算法</h1><h1 id="十五-垃圾回收相关概念"><a href="#十五-垃圾回收相关概念" class="headerlink" title="十五 垃圾回收相关概念"></a>十五 垃圾回收相关概念</h1><h1 id="十六-垃圾回收器"><a href="#十六-垃圾回收器" class="headerlink" title="十六. 垃圾回收器"></a>十六. 垃圾回收器</h1>]]></content>
      <categories>
        <category>JVM虚拟机学习</category>
      </categories>
      <tags>
        <tag>Java底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2021/02/05/Dubbo/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-分布式理论基础"><a href="#1-分布式理论基础" class="headerlink" title="1. 分布式理论基础"></a>1. 分布式理论基础</h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a>1.1 什么是分布式系统？</h3><p>分布式系统(distributed system)是建立在网络之上的软件系统。</p>
<p>随着互连网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需    一个<strong>治理系统</strong>（比如说Dubbo）确保架构有条不紊的演进。</p>
<h3 id="1-2-发展演变"><a href="#1-2-发展演变" class="headerlink" title="1.2 发展演变"></a>1.2 发展演变</h3><p><img src="https://img-blog.csdnimg.cn/20210205104436391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>单一应用架构</strong> 比如：超市的收银系统、公司的管理系统、小型的网站应用</p>
<ul>
<li><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</p>
</li>
<li><p>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205104557417.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>缺点</strong>：</p>
<p>扩展应用(带着整个应用扩展)不容易、协调开发不容易(同时在一个上去开发)</p>
</li>
<li><p><strong>垂直应用架构</strong></p>
<ul>
<li><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</p>
</li>
<li><p>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104459438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>每一个模块从页面、业务逻辑、程序、数据库都是完整的</p>
<p><strong>优点</strong>：开发和维护不同的应用互不干扰、性能扩展容易、</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>界面+业务逻辑的实现分离</li>
<li><strong>应用之间不可能完全独立，大量的应用之间需要交互</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>分布式服务架构</strong> </p>
<ul>
<li><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p>
</li>
<li><p>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104517127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>优点</strong>：把核心业务抽取出来，只需要改动界面即可。服务器上的核心业务还在服务器上。</p>
<p><strong>缺点</strong>：不能实时管理服务器。造成浪费</p>
<p><strong>分布式服务框架(RPC)：</strong>远程过程调用 </p>
<p>分布式架构的<strong>难点</strong>就是如何拆分业务+如何远程过程调用</p>
</li>
</ul>
</li>
<li><p><strong>流动计算架构</strong> </p>
<ul>
<li><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</p>
</li>
<li><p>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104534489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>负责维护整个服务集群，可以实时的管理集群容量，比如A服务器访问量大了，可以给A动态的多来几台。</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-RPC"><a href="#1-3-RPC" class="headerlink" title="1.3 RPC"></a>1.3 RPC</h3><p><strong>什么叫RPC？</strong></p>
<p><strong>RPC【Remote Procedure Call】</strong>是指远程过程调用，是一种进程间的通信方式，它是一种技术思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显示编码这个远程调用的细节。即程序员无论是调用本地还是远程的函数，本质上编写的调用代码基本相同。</p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210205104635464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>通俗说来就是A和B两个服务器建立起一个网络连接，他们之间进行通信。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104619296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>影响RPC机制的两个因素就是<strong>①序列化和反序列化机制的速度②能否快速的在各个服务器之间建立连接即通信效率</strong></p>
<p><strong>RPC的两个核心模块：通信、序列化</strong></p>
<p><strong>RPC 框架有很多如：</strong></p>
<p><strong>dubbo、</strong>gRPC、Thrift、HSF(High Speed Service Framework)</p>
<h1 id="二、Dubbo配置"><a href="#二、Dubbo配置" class="headerlink" title="二、Dubbo配置"></a>二、Dubbo配置</h1><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2. Dubbo核心概念"></a>2. Dubbo核心概念</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>Apache Dubbo</strong>是一款高性能、轻量级的开源Java RPC框架，他提供了三大核心能力：<strong>①面向接口的远程方法调用，②智能容错和负载均衡，以及③服务自动注册和发现。</strong></p>
<p>官网：<a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></p>
<p><strong>Dubbo的特性；</strong></p>
<ul>
<li><p>面向<strong>接口</strong>代理的高性能RPC调用：为开发者屏蔽远程调用底层细节</p>
</li>
<li><p>服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104655848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>  <strong>注册中心</strong>相当于所有服务都在哪个服务器上的一个清单比如支付业务在4 6 9服务器上有安装负载均衡看选择哪个服务器合适</p>
<ul>
<li><p>运行期流量调度：内置条件、脚本等路由策略</p>
</li>
<li><p>智能负载均衡</p>
</li>
<li><p>高度可扩展能力：遵循微内核+插件的设计原则</p>
</li>
<li><p>可视化的服务治理与运维</p>
</li>
</ul>
<h3 id="2-2高性能Java-RPC框架——Dubbo设计框架"><a href="#2-2高性能Java-RPC框架——Dubbo设计框架" class="headerlink" title="2.2高性能Java RPC框架——Dubbo设计框架"></a>2.2高性能Java RPC框架——Dubbo设计框架</h3><p><img src="https://img-blog.csdnimg.cn/20210205104713663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
</li>
<li><p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
</li>
<li><p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
</li>
<li><p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
</li>
</ul>
<h3 id="2-3-zookeeper注册中心"><a href="#2-3-zookeeper注册中心" class="headerlink" title="2.3 zookeeper注册中心"></a>2.3 zookeeper注册中心</h3><p><strong>Zookeeper</strong>是Apache Hadoop的子项目，是一个树型的目录结构，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205104734728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-dubbo-helloword实例"><a href="#3-dubbo-helloword实例" class="headerlink" title="3.dubbo-helloword实例"></a>3.dubbo-helloword实例</h2><h3 id="3-1提出需求"><a href="#3-1提出需求" class="headerlink" title="3.1提出需求"></a>3.1提出需求</h3><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>订单服务web模块</td>
<td>创建订单等</td>
</tr>
<tr>
<td>用户服务service模块</td>
<td>查询用户地址等</td>
</tr>
</tbody></table>
<p>测试预期结果：</p>
<pre><code>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210205104752913.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>本地存根</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210205165308490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>SpringBoot与dubbo整合的三种方式：</strong></p>
<p>1）导入dubbo-starter依赖，在application.properties配置属性，使用@Service【暴力服务】和使用@Reference【 引用服务】，同时还要在启动类中开启dubbo注解功能@EnableDubbo</p>
<p>2）保留dubbo.xml配置文件;</p>
<p>导入dubbo-start依赖、使用@ImportResource导入dubbo的配置文件即可【在启动类中配置@ImportResource(location=”classpath:provider.xml”)】</p>
<p>3）使用注解API方式；</p>
<p>将原先配置文件xml中的每一个组件通过手动创建到容器中，即写一个配置类@Configuration，将每一个组件通过@Bean注入到容器中、在启动类中使用@DubboComponentScan()或者用@EnableDubbo(scanBasePackages=”包名”)  @Service注解暴露出来</p>
<h1 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h1><h2 id="1、zookeeper宕机与dubbo直连"><a href="#1、zookeeper宕机与dubbo直连" class="headerlink" title="1、zookeeper宕机与dubbo直连"></a>1、zookeeper宕机与dubbo直连</h2><p>zookeeper注册中心宕机，还可以消费dubbo暴漏的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍然能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍然能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等服务提供者恢复</li>
</ul>
<p>高可用：通过设计，减少系统不能提供服务的时间</p>
<p><strong>dubbo直连</strong></p>
<p>直接绕过注册中心与服务相连，是通过@Reference注解中直接设置服务提供者的url</p>
<h2 id="2、集群下dubbo负载均衡配置"><a href="#2、集群下dubbo负载均衡配置" class="headerlink" title="2、集群下dubbo负载均衡配置"></a>2、集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随即调用</p>
<p><strong>负载均衡策略：</strong></p>
<ul>
<li><p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165330907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li><p>RoundRobin LoadBalance</p>
<p>轮询，按公约后 的权重设置轮询比率。</p>
<p>存在慢的提供者累计请求的问题，比如，第二台机器很慢，但没挂，当请求调到第二台时就卡在那 ，久而久之，所有请求都卡在调到第二台上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165342580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>LeastActive LoadBalance</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少的请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205165356499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性Hash，相同参数的请求总是发到同一提供者</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平衡到其他提供者，不会引起剧烈变动。算法参见:<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
<p>缺省只对第一个参数Hash，如果要修改，请配置&lt;dubbo:parameter key=”hash.arguments” value=”0.1”/&gt;</p>
<p>缺省用160份虚拟节点，如果要修改，请配置&lt;dubbo:parameter key=”hash.nodes” value=”320”/&gt;</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210205165408957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-整合hystrix，服务容错"><a href="#3-整合hystrix，服务容错" class="headerlink" title="3.整合hystrix，服务容错"></a>3.整合hystrix，服务容错</h2><h3 id="1）什么是服务降级？"><a href="#1）什么是服务降级？" class="headerlink" title="1）什么是服务降级？"></a>1）什么是<strong>服务降级</strong>？</h3><p><strong>当服务器压力剧增的情况下，根据实际业务及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作</strong>。</p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165421518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2）集群容错"><a href="#2）集群容错" class="headerlink" title="2）集群容错"></a>2）<strong>集群容错</strong></h3><p>在集群调用失败时，Dubbo提供了多种容错方案，缺省为failover重试。</p>
<p><strong>集群容错模式</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165434577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>集群模式配置：</strong></p>
<p>按照一下示例在服务提供方和消费方配置集群模式</p>
<p>&lt;dubbo:service cluste”failsafe/&gt;</p>
<p>或</p>
<p>&lt;dubbo:reference cluste”failsafe/&gt;</p>
<h3 id="3）整合hystrix"><a href="#3）整合hystrix" class="headerlink" title="3）整合hystrix"></a>3）<strong>整合hystrix</strong></h3><p>Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控 和配置等功能。</p>
<p><img src="https://img-blog.csdnimg.cn/2021020516544827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="四、Dubbo原理"><a href="#四、Dubbo原理" class="headerlink" title="四、Dubbo原理"></a>四、Dubbo原理</h1><h3 id="1）RPC原理"><a href="#1）RPC原理" class="headerlink" title="1）RPC原理"></a>1）RPC原理</h3><p><img src="https://img-blog.csdnimg.cn/20210205165544703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>8）client stub接收消息，并进行解码</p>
<p><strong>9）服务消费者得到最终结果</strong></p>
<p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明发，不可见的。</p>
<h3 id="2-netty通信原理"><a href="#2-netty通信原理" class="headerlink" title="2)netty通信原理"></a>2)netty通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p><img src="https://img-blog.csdnimg.cn/20210205165558801.png#pic_center" alt="在这里插入图片描述"></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MGZup9N3-1612515161931)(C:\Users\lenovo\Desktop\M5.png)]</p>
<h4 id="Netty原理"><a href="#Netty原理" class="headerlink" title="Netty原理"></a>Netty原理</h4><p><img src="https://img-blog.csdnimg.cn/20210205165615439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3）dubbo原理"><a href="#3）dubbo原理" class="headerlink" title="3）dubbo原理"></a>3）dubbo原理</h3><ul>
<li>dubbo原理-框架设计</li>
</ul>
<ul>
<li>dubbo原理-启动解析  加载配置信息</li>
</ul>
<ul>
<li>dubbo原理-服务暴漏</li>
</ul>
<ul>
<li>dubbo原理-服务引用</li>
</ul>
<ul>
<li>dubbo原理-服务调用</li>
</ul>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode每日一题</title>
    <url>/2021/01/18/Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="721题—账户合并"><a href="#721题—账户合并" class="headerlink" title="721题—账户合并"></a>721题—<font color='orange'>账户合并</font></h2><p>题目：<a href="https://leetcode-cn.com/problems/accounts-merge">力扣</a></p>
<h3 id="知识点：并查集-哈希表"><a href="#知识点：并查集-哈希表" class="headerlink" title="知识点：并查集+哈希表"></a>知识点：并查集+哈希表</h3><p><strong>一。什么是并查集？</strong>？</p>
<p><a href="https://baike.sogou.com/v54997185.htm?fromTitle=%E5%B9%B6%E6%9F%A5%E9%9B%86">百度百科</a></p>
<p>并查集是一种<strong>树型</strong> 的数据结构，用于处理一些不交集的合并及查询问题。顾名思义，就是交集为空集的集合。有一个<strong>联合-查找算法</strong>定义了两个用于此数据结构的操作：</p>
<p><strong>Find：</strong>确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一个子集。</p>
<p><strong>Union</strong>：将两个子集合并成同一个集合</p>
<p>为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为<strong>代表</strong>，表示整个集合。接着，<strong>Find(x) ** 返回x所属集合的代表，而</strong>Union**使用两个集合的代表作为参数</p>
<p>对于并查集，主要有如下操作：</p>
<ol>
<li><strong>合并两个集合(“并”)</strong></li>
<li><strong>判断两个元素是否属于同一个集合(“查“）</strong></li>
</ol>
<p>知乎上有一个通俗易懂的帖子，有助于理解<strong>并查集</strong>。<a href="https://zhuanlan.zhihu.com/p/35314141">并查集</a></p>
<p>对于并查集还有两个优化：<font color='red'><strong>路径压缩和按秩合并</strong></font></p>
<p><strong>二.解题思路</strong></p>
<p>根据题意可知：</p>
<ul>
<li><strong>存在相同邮箱的账号一定属于同一个人</strong></li>
<li><strong>名称相同的账户不一定属于同一个人</strong></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/accounts-merge/solution/tu-jie-yi-ran-shi-bing-cha-ji-by-yexiso-5ncf/">题解</a></p>
<p><img src="C:\Users\lenovo\Desktop\账户合并.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        UnionFind myUnion = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                String curEmail = accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> id = myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RBAC</title>
    <url>/2021/01/17/RBAC/</url>
    <content><![CDATA[<h1 id="RBAC学习"><a href="#RBAC学习" class="headerlink" title="RBAC学习"></a>RBAC学习</h1><h2 id="一-什么是RBAC？"><a href="#一-什么是RBAC？" class="headerlink" title="一. 什么是RBAC？"></a>一. 什么是RBAC？</h2><p>RBAC(Role-Based Access Control)基于角色的访问控制。这种模型（用户-角色-权限模型）的基本概念是把许可权与角色联系在一起，用户通过充当合适角色的成员而获得该角色的许可权。一个用户拥有若干个角色，每一个角色拥有若干个权限。在这种模型中，用户与角色之间，角色与权限(功能)之间，一般都是多对多的关系。</p>
<p>RBAC重要对象：</p>
<ol>
<li><strong>用户</strong>：角色施加的主体；用户通过拥有某个或多个角色以得到对应的权限</li>
<li><strong>角色</strong>：一组权限的集合</li>
<li><strong>权限</strong>：用于限定能够访问的一个资源</li>
</ol>
<p>权限赋予给角色，而把角色又赋予用户</p>
<h2 id="二-RBAC级别"><a href="#二-RBAC级别" class="headerlink" title="二.RBAC级别"></a>二.RBAC级别</h2><h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>定义了能构成一个RBAC控制系统的最小的元素集合，<strong>RBAC0是RBAC的核心模型</strong>，其他的级别都是建立在该级别的基础上。</p>
<p>主要由四部分组成：</p>
<ol>
<li>用户</li>
<li>角色</li>
<li>许可</li>
<li>会话</li>
</ol>
<p>在RBAC之中，包含用户users(USERS)、角色roles(ROLES)、目标objects(OBS)、操作operations(OPS)、许可权permissions(PRMS)五个基本数据元素，<font color='orange'>权限被赋予角色</font>,而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的权限，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展</p>
<p><img src="C:\Users\lenovo\Desktop\y.png"></p>
<h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>引入角色之间的继承关系，进行了角色的分层，也就是说有了上下级别的关系。</p>
<p>角色之间的继承关系可以分为继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构。</p>
<p>RBAC1是对RBAC0进行了扩展，是RBAC的角色分层模型，RBAC1引入了角色继承概念，有了继承就有了上下级的包含关系。</p>
<h3 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h3><p>该模型中添加了责任分离关系</p>
<p>一些特殊的角色是不能赋予给一个用户的，比如：财务当中的会计和出纳角色不能同时赋予给一个人</p>
<h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>RBAC3包含了RBAC1和RBAC2，既提供了角色间的继承关系，又提供了责任分离关系</p>
<h1 id="三-RBAC实战案例"><a href="#三-RBAC实战案例" class="headerlink" title="三.RBAC实战案例"></a>三.RBAC实战案例</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1   需求"></a>1   需求</h2><ol>
<li>实现用户登录功能</li>
<li>使用RBAC0模型管理系统权限</li>
<li>对系统的菜单以及菜单中的链接进行管理</li>
<li>用户登录后首页根据用户角色显示该角色所对应的菜单</li>
<li>禁止用户越级访问</li>
</ol>
<h2 id="2-技术选择"><a href="#2-技术选择" class="headerlink" title="2  技术选择"></a>2  技术选择</h2><ol>
<li>框架：SpringMVC+Spring+Mybatis</li>
<li>数据库：Mysql</li>
</ol>
<h2 id="3-数据库设计"><a href="#3-数据库设计" class="headerlink" title="3  数据库设计"></a>3  数据库设计</h2><p>数据库的设计表</p>
<h2 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4 权限管理"></a>4 权限管理</h2><h3 id="1越级访问"><a href="#1越级访问" class="headerlink" title="1越级访问"></a>1越级访问</h3><p>所谓越级访问就是使用低级本的角色访问高级别的资源</p>
<p><strong>DTree</strong></p>
<p><strong>在菜单生成的过程中，所有的功能都落脚于子结点上，页面的树型菜单就很难生成，外连接可以查到孤儿数据的</strong></p>
<p><strong>权限过滤器</strong></p>
]]></content>
      <tags>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法学习 &amp;&amp;  Typora工具的使用</title>
    <url>/2021/01/17/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-Typora%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>markdown使用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <url>/2021/01/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>为了可以让新接触算法的小白可以更快对算法有一个直观的认识，先给大家引出几个经典算法题来激发大家对算法的兴趣，毕竟不会算法的程序员不是一个好的程序员，希望大家可以对算法有一个很好的重视。要明白算法是程序的灵魂，如果不想成为代码工人，那就花时间来研究数据结构和算法，程序=数据结构+算法。数据结构是算法的基础，想学好算法。需要把数据结构学到位。</p>
<h2 id="一-引出几个经典的算法面试题"><a href="#一-引出几个经典的算法面试题" class="headerlink" title="一. 引出几个经典的算法面试题##"></a>一. 引出几个经典的算法面试题##</h2><h3 id="1-1字符串匹配问题"><a href="#1-1字符串匹配问题" class="headerlink" title="1.1字符串匹配问题"></a>1.1字符串匹配问题</h3><ul>
<li>算法：暴力匹配(简单、但是效率低)、KMP算法(部分匹配表)——面试题会用这个算法来解决</li>
<li>要求：用最快的速度来完成匹配、</li>
<li>思路是什么？</li>
</ul>
<h3 id="1-2汉诺塔游戏"><a href="#1-2汉诺塔游戏" class="headerlink" title="1.2汉诺塔游戏"></a>1.2汉诺塔游戏</h3><p>将A塔的所有圆盘移动到C塔并且规定，小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘<br><img src="https://github.com/jianier/pictureRepo/blob/master/5.png" alt="image"></p>
<h3 id="1-3八皇后问题——回溯算法的经典案例"><a href="#1-3八皇后问题——回溯算法的经典案例" class="headerlink" title="1.3八皇后问题——回溯算法的经典案例"></a>1.3八皇后问题——回溯算法的经典案例</h3><p>1)即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？<br>2)用图论的方法解出有92种<br>3)分治算法</p>
<h3 id="1-4马踏棋盘算法又称骑士周游问题"><a href="#1-4马踏棋盘算法又称骑士周游问题" class="headerlink" title="1.4马踏棋盘算法又称骑士周游问题"></a>1.4马踏棋盘算法又称骑士周游问题</h3><p>1)将马随机放在国际象棋的8×8棋盘的某个方格中。马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格。<br><img src="C:\Users\lenovo\Desktop\6.png" alt="avatar"><br>2)会使用到图图的深度优化遍历算法(DFS)+贪心算法优化<br>#二. 数据结构<br>##2.1线性和非线性结构  ##</p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>2.1.1 线性结构的特点：数据元素之间存在“一对一的”线性关系<br>2.1.2 线性结构有两种不同的存储结构：<br>1）顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表种的存储元素是连续的<br>2）链式存储的线性表称为链表，链表种的存储元素“不一定是连续的”，元素节点中存放数据元素以及相邻元素的地址信息<br>2.1.3 线性结构常见的有:数组、队列、链表和栈</p>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>1）非线性结构包括：二维数组、多维数组、广义表、树结构、图结构<br>##2.2稀疏数组和队列  ##</p>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>2.2.1应用：五子棋存盘退出和续上盘 、地图<br>2.2.2概念：当一个数组种大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。<br>稀疏数组的处理方法是：<br>1）记录数组一工有几行几列，有多少个不同的值<br>2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。<br><img src="https://github.com/jianier/pictureRepo/blob/master/7.png" alt="image"></p>
<h3 id="2-2-3-二维数组转稀疏数组的思路"><a href="#2-2-3-二维数组转稀疏数组的思路" class="headerlink" title="2.2.3 二维数组转稀疏数组的思路"></a>2.2.3 二维数组转稀疏数组的思路</h3><p>1）遍历 原始的二维数组，得到有效数据的个数sum<br>2)根据sum就可以创建稀疏数组sparseArr  int[sum+1][3]<br>3)将二维数组的有效数据存入到稀疏数组中 </p>
<h3 id="2-2-4-稀疏数组转二维数组的思路"><a href="#2-2-4-稀疏数组转二维数组的思路" class="headerlink" title="2.2.4 稀疏数组转二维数组的思路"></a>2.2.4 稀疏数组转二维数组的思路</h3><p>1）先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组。比如上面的chessArr2=int[11][11]<br>2）在读取稀疏数组后几行的数据，并赋给原始的二维数组<br><img src="https://github.com/jianier/pictureRepo/blob/master/8.png" alt="image"><br>##2.3链表 ##</p>
<h3 id="2-3-1链表"><a href="#2-3-1链表" class="headerlink" title="2.3.1链表"></a>2.3.1链表</h3><h3 id="2-3-2单链表"><a href="#2-3-2单链表" class="headerlink" title="2.3.2单链表"></a>2.3.2单链表</h3><h3 id="2-3-3双向链表"><a href="#2-3-3双向链表" class="headerlink" title="2.3.3双向链表"></a>2.3.3双向链表</h3><h3 id="2-3-4单向环形链表"><a href="#2-3-4单向环形链表" class="headerlink" title="2.3.4单向环形链表"></a>2.3.4单向环形链表</h3><h2 id="2-4栈"><a href="#2-4栈" class="headerlink" title="2.4栈"></a>2.4栈</h2><h2 id="2-5前缀、中缀、后缀表达式-逆波兰表达式"><a href="#2-5前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="2.5前缀、中缀、后缀表达式(逆波兰表达式)"></a>2.5前缀、中缀、后缀表达式(逆波兰表达式)</h2><h3 id="2-5-1逆波兰计算器"><a href="#2-5-1逆波兰计算器" class="headerlink" title="2.5.1逆波兰计算器"></a>2.5.1逆波兰计算器</h3><h2 id="2-6递归"><a href="#2-6递归" class="headerlink" title="2.6递归"></a>2.6递归</h2><h3 id="2-6-1迷宫问题"><a href="#2-6-1迷宫问题" class="headerlink" title="2.6.1迷宫问题"></a>2.6.1迷宫问题</h3><h3 id="2-6-2八皇后问题-回溯算法"><a href="#2-6-2八皇后问题-回溯算法" class="headerlink" title="2.6.2八皇后问题(回溯算法)"></a>2.6.2八皇后问题(回溯算法)</h3><h2 id="2-7八大排序算法"><a href="#2-7八大排序算法" class="headerlink" title="2.7八大排序算法"></a>2.7八大排序算法</h2><h3 id="2-7-1内部-使用内存-排序栈"><a href="#2-7-1内部-使用内存-排序栈" class="headerlink" title="2.7.1内部(使用内存)排序栈"></a>2.7.1内部(使用内存)排序栈</h3><ol>
<li>插入排序：<br>1.1直接插入排序<br>1.2希尔排序</li>
<li>选择排序<br>2.1简单选择排序<br>2.2堆排序</li>
<li>交换排序<br>3.1冒泡排序<br>3.2快速排序 </li>
<li>归并排序</li>
<li>基数排序(桶排序)<h3 id="2-7-2外部-使用内存和外存结合-排序栈"><a href="#2-7-2外部-使用内存和外存结合-排序栈" class="headerlink" title="2.7.2外部(使用内存和外存结合)排序栈"></a>2.7.2外部(使用内存和外存结合)排序栈</h3><h2 id="2-8算法的时间复杂度"><a href="#2-8算法的时间复杂度" class="headerlink" title="2.8算法的时间复杂度"></a>2.8算法的时间复杂度</h2></li>
</ol>
<ul>
<li><p>常数阶  </p>
</li>
<li><p>对数阶  </p>
</li>
<li><p>线性阶  </p>
</li>
<li><p>线性对数阶  </p>
</li>
<li><p>平方阶  </p>
</li>
<li><p>立方阶  </p>
</li>
<li><p>k次方阶  </p>
</li>
<li><p>指数阶级O(2^n)<br>##2.9查找算法##</p>
</li>
</ul>
<ol>
<li>线性查找算法</li>
<li>二分查找算法</li>
<li>插值查找算法</li>
<li>斐波那契(黄金分割)算法<h2 id="2-10哈希表"><a href="#2-10哈希表" class="headerlink" title="2.10哈希表##"></a>2.10哈希表##</h2><h2 id="2-11树"><a href="#2-11树" class="headerlink" title="2.11树##"></a>2.11树##</h2></li>
<li>二叉树</li>
<li>顺序存储二叉树</li>
<li>线索化二叉树<h2 id="2-12树结构的实际应用"><a href="#2-12树结构的实际应用" class="headerlink" title="2.12树结构的实际应用##"></a>2.12树结构的实际应用##</h2></li>
</ol>
<ul>
<li>堆排序</li>
<li>赫夫曼树</li>
<li>赫夫曼编码<br>1)最佳实践-数据压缩(创建赫夫曼树)<br>2)最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)<br>3）最佳实践-数据解压(使用赫夫曼编码)<br>4）最佳实践-文件压缩<br>5）最佳实践-文件解压(文件恢复)  </li>
<li>二叉排序树</li>
<li>平衡二叉树(AVL树)</li>
<li>多路查找树<br>二叉树与B树<br>2-3树<br>B树、B+树和B*树<br>##2.12图##</li>
</ul>
<ol>
<li>图的创建和深度优先搜索算法</li>
</ol>
<h1 id="三-算法"><a href="#三-算法" class="headerlink" title="三.算法"></a>三.算法</h1><h2 id="3-1二分查找算法-非递归"><a href="#3-1二分查找算法-非递归" class="headerlink" title="3.1二分查找算法(非递归)##"></a>3.1二分查找算法(非递归)##</h2><h2 id="3-2分治算法"><a href="#3-2分治算法" class="headerlink" title="3.2分治算法##"></a>3.2分治算法##</h2><p>汉诺塔</p>
<h2 id="3-3动态规划算法"><a href="#3-3动态规划算法" class="headerlink" title="3.3动态规划算法##"></a>3.3动态规划算法##</h2><p>0-1背包问题</p>
<h2 id="3-4KMP算法"><a href="#3-4KMP算法" class="headerlink" title="3.4KMP算法##"></a>3.4KMP算法##</h2><h2 id="3-5贪心算法"><a href="#3-5贪心算法" class="headerlink" title="3.5贪心算法##"></a>3.5贪心算法##</h2><p>集合覆盖问题</p>
<h2 id="3-6普利姆算法"><a href="#3-6普利姆算法" class="headerlink" title="3.6普利姆算法##"></a>3.6普利姆算法##</h2><p>修路问题</p>
<h2 id="3-7克鲁斯卡尔算法"><a href="#3-7克鲁斯卡尔算法" class="headerlink" title="3.7克鲁斯卡尔算法##"></a>3.7克鲁斯卡尔算法##</h2><p>公交站问题</p>
<h2 id="3-8迪杰斯特拉算法-Dijksta"><a href="#3-8迪杰斯特拉算法-Dijksta" class="headerlink" title="3.8迪杰斯特拉算法(Dijksta)##"></a>3.8迪杰斯特拉算法(Dijksta)##</h2><p>最短路径算法</p>
<h2 id="3-9弗洛伊德算法-Floyd"><a href="#3-9弗洛伊德算法-Floyd" class="headerlink" title="3.9弗洛伊德算法(Floyd)##"></a>3.9弗洛伊德算法(Floyd)##</h2><p>弗洛伊德算法vs迪杰斯特拉算法</p>
<h2 id="3-10马踏棋盘算法"><a href="#3-10马踏棋盘算法" class="headerlink" title="3.10马踏棋盘算法##"></a>3.10马踏棋盘算法##</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro</title>
    <url>/2021/01/19/Shiro/</url>
    <content><![CDATA[<h1 id="Shiro的简介"><a href="#Shiro的简介" class="headerlink" title="Shiro的简介"></a>Shiro的简介</h1><h2 id="一-为什么学习Shiro"><a href="#一-为什么学习Shiro" class="headerlink" title="一.为什么学习Shiro?"></a>一.<strong>为什么学习Shiro?</strong></h2><p><strong>A、目前使用遇到的问题？</strong></p>
<ol start="2">
<li>目前学习 的写的操作代码整体不太安全</li>
<li>使用RBAC进行角色访问控制的时候，代码书写起来相对比较麻烦</li>
</ol>
<p><strong>B、解决方案</strong></p>
<ol>
<li><strong>Spring Security  安全框架</strong>   缺点：基于Spring之上的，局限性比较大</li>
<li><strong>Shiro</strong>    可以在javaEE  javaSE  分布式项目上</li>
</ol>
<p><strong>C、什么是Shiro?</strong></p>
<p>Apache Shiro 是一个强大而灵活的开源<font color='red'>安全</font>框架，它干净利落地处理<font color='red'>身份认证</font>，<font color='orange'>授权</font>，<font color='cornflowerblue'>企业会话管理</font>和<font color='red'>加密</font>。</p>
<h2 id="二-Shiro中的体系组成"><a href="#二-Shiro中的体系组成" class="headerlink" title="二. Shiro中的体系组成"></a>二. Shiro中的体系组成</h2><p><img src="C:\Users\lenovo\Desktop\z.png"></p>
<p>Shiro的开发团队成为“<strong>应用程序的四大基石”</strong>——身份验证、授权、会话管理和加密作为其目标。</p>
<ul>
<li><strong>Authentication</strong>：<strong>身份验证</strong>/<strong>认证</strong>–有时也简称为“<strong>登录</strong>”，这是一个证明用户是他们所说的他们是谁的行为。</li>
<li><strong>Authorization</strong>：<strong>授权</strong>–赋予角色不同的菜单功能，访问控制的过程。</li>
<li><strong>Session Management</strong>：<strong>管理登录用户的信息</strong></li>
<li><strong>Cryptography</strong>：<strong>加密技术</strong> 比如MD5加密算法等</li>
</ul>
<p>也提供了<strong>额外的功能</strong>来支持和加强在不同环境下所关注的方面：</p>
<ul>
<li>**Web Support:**Shiro对Web项目进行的支持</li>
<li>**Caching:**缓存  可以安全快速的操作</li>
<li><strong>Concurrency</strong>：支持并发多线程的处理</li>
<li>**Testing:**测试</li>
<li>**”Run As”**：可以实现在一个用户允许的前提下，使用另一个用户访问</li>
<li>**”Remember Me”**：记住我</li>
</ul>
<h2 id="三-Shiro的架构"><a href="#三-Shiro的架构" class="headerlink" title="三. Shiro的架构"></a>三. Shiro的架构</h2><p><img src="C:\Users\lenovo\Desktop\w.png"></p>
<ul>
<li><strong><font color='red'>Subject</font></strong>(org.apache.shiro.subject.Subject)<br>当前与软件进行交互的实体（<font color='red'>用户</font>，<font color='orange'>第三方服务</font>，<font color='cornflowerblue'>cron job</font>，等等）的安全特定“视图”。</li>
<li><strong><font color='red'>SecurityManager</font></strong>(org.apache.shiro.mgt.SecurityManager)<br>如上所述，SecurityManager 是<font color='red'> Shiro 架构的心脏</font>。它基本上是一个“保护伞”对象，协调其管理的组件以确保<br>它们能够一起顺利的工作。它还管理每个应用程序用户的 Shiro 的视图，因此它知道如何执行每个用户的安全<br>操作。类似于SpringMVC中的入口Servlet即DispatchServlet</li>
<li><strong><font color='red'>Realms</font></strong>(org.apache.shiro.realm.Realm)<br>如上所述，Realms 在 Shiro 和你的应用程序的安全数据之间担当**<font color='red'>“桥梁”或“连接器”</font><strong>。当它实际上与安全<br>相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro 从一个或多个为应用<br>程序配置的 Realm 中寻找许多这样的东西。你可以按你的需要配置多个 Realm（通常</strong>一个数据源一个 Realm**），<br>且 Shiro 将为身份验证和授权对它们进行必要的协调。</li>
</ul>
<h2 id="四-使用Shiro实现登录的操作"><a href="#四-使用Shiro实现登录的操作" class="headerlink" title="四. 使用Shiro实现登录的操作"></a>四. 使用Shiro实现登录的操作</h2><p>第一步：导包</p>
<p>第二步：书写shiro.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zs=<span class="number">123</span></span><br><span class="line">sxt=root</span><br></pre></td></tr></table></figure>
<p>第三步：<strong>书写测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中（相当于数据源）的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="五-Shiro验证时异常分析"><a href="#五-Shiro验证时异常分析" class="headerlink" title="五. Shiro验证时异常分析"></a>五. Shiro验证时异常分析</h2><p><strong>DisabledAccountException</strong><br>账户失效异常<br><strong>ConcurrentAccessException</strong><br>竞争次数过多<br><strong>ExcessiveAttemptsException</strong><br>尝试次数过多<br><strong>UnknownAccountException</strong><br>用户名不正确<br><strong>IncorrectCredentialsException</strong><br>凭证（密码）不正确<br><strong>ExpiredCredentialsException</strong><br>凭证过期<br>使用 shiro 做异常处理的时候，尽量把<strong>异常信息表示的婉转一点</strong>，这样有助于提升代码的安全性</p>
<h2 id="六-Shiro的认证流程"><a href="#六-Shiro的认证流程" class="headerlink" title="六. Shiro的认证流程"></a>六. Shiro的认证流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、通过 shiro 相关的 API 创建了 SecurityManager 以及获得subject 实例</span><br><span class="line"><span class="number">2</span>、封装了 token 信息</span><br><span class="line"><span class="number">3</span>、详细描述</span><br><span class="line">通过 subject.login(token)进行用户认证</span><br><span class="line">Subject 接受 token 信息 ，通过 DelegatingSubject将 token 委托给 securityManager 完成认证</span><br><span class="line">securityManager 通过使用 DefaultSecurityManager完成相关功能,</span><br><span class="line">由 DefaultSecurityManager 中的 login 方法完成对应的认证,在 login 中调用了AuthenticatingSecurityManager中的authenticate 方法完成认证,使用其中的doAuthenticate获得realms信息,如果是单个直接进行比较，判断是否成功，如果是多个 raalm 需要使用验证策略完成对应的认证工作</span><br></pre></td></tr></table></figure>
<h2 id="七-Shiro的认证策略"><a href="#七-Shiro的认证策略" class="headerlink" title="七. Shiro的认证策略"></a>七. Shiro的认证策略</h2><p>定了如果有多个数据源的时候应该如何操作</p>
<ol>
<li><strong>AtLeastOneSuccessfulStrategy</strong><br>如果一个（或更多）Realm 验证成功，则整体的尝试被认为是成功的。<br>如果没有一个验证成功，<br>则整体尝试失败 类似于 java 中的 &amp;</li>
<li><strong>FirstSuccessfulStrategy</strong><br>只有第一个成功地验证的 Realm 返回的信息将被使用。所有进一步的<br>Realm 将被忽略。如果没有一个验证成功，则整体尝试失败。<br>类似于 java 中的 &amp;&amp;</li>
<li><strong>AllSucessfulStrategy</strong><br>为了整体的尝试成功，所有配置的 Realm 必须验证成功。如果没有一个验<br>证成功，则整体尝试失败</li>
</ol>
<h2 id="八-自定义Realm"><a href="#八-自定义Realm" class="headerlink" title="八. 自定义Realm"></a>八. 自定义Realm</h2><ol>
<li><p>为什么使用自定义Realm？</p>
<p>我们使用JDBCRealm的时候发现，shiro的底层自己封装了数据库表的名称和字段的名称，这样就造成了使用起来非常的不方便。</p>
</li>
<li><p>解决方案</p>
<p>自定义Realm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义realm：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">       <span class="comment">//authenticationToken封装了用户的信息</span></span><br><span class="line">        <span class="comment">//authenticationToken.getPrincipal()得到的是用户名比如：root</span></span><br><span class="line">        System.out.println(authenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/yjy&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ps = conn.prepareStatement(<span class="string">&quot;select pwd from admin where uname=? &quot;</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, (String) authenticationToken.getPrincipal());</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息  密码作比较</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro-jdbc2.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;sxt&quot;</span>, <span class="string">&quot;toot&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shiro---认证流程：</span></span><br><span class="line"><span class="comment"> *   A、通过shiro相关的API创建了SecurityManager以及获得subject实例</span></span><br><span class="line"><span class="comment"> *   B、封装了token信息</span></span><br><span class="line"><span class="comment"> *   C、详细描述：</span></span><br><span class="line"><span class="comment"> *       通过subject.login(token)进行用户认证</span></span><br><span class="line"><span class="comment"> *       subject接收token信息，通过DelegatingSubject</span></span><br><span class="line"><span class="comment"> *       将token委托给securityManager完成认证</span></span><br><span class="line"><span class="comment"> *       securityManager通过使用DefaultSecurityManager</span></span><br><span class="line"><span class="comment"> *       完成相关功能由DefaultSecurityManager中的login方法完</span></span><br><span class="line"><span class="comment"> *       成对应的认证在login中调用了</span></span><br><span class="line"><span class="comment"> *       AuthenticatingSecurityManager</span></span><br><span class="line"><span class="comment"> *       中的authenticate方法完成认证</span></span><br><span class="line"><span class="comment"> *       使用其中的doAuthenticate获得realms信息如果是的那个直接进</span></span><br><span class="line"><span class="comment"> *       行比较，判断是否成功，如果是多个realms需要使用验证策略</span></span><br><span class="line"><span class="comment"> *       完成对应的认证工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="九-加密算法"><a href="#九-加密算法" class="headerlink" title="九. 加密算法"></a>九. 加密算法</h2><p><strong>散列算法(算法加密)</strong></p>
<ol>
<li>在身份认证的过程中往往都会涉及到加密,如果不加密,这个时<br> 候信息就会非常的不安全,shiro 中提供的算法比较多 如 MD5、SHA 等<br> 使用 <strong>MD5</strong> 进行 ‘’1111 加密<br> b59c67bf196a4758191e42f76670ceba  单纯的进行MD5加密的话，可以通过在网上通过一张表解密，所以还要结合加盐操作进行加密<br> 进行<strong>加盐操作</strong><br> 1111+姓名=</li>
<li> 实现的案例</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用MD5加密</span></span><br><span class="line">        Md5Hash md5 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加盐</span></span><br><span class="line">        Md5Hash md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line">        <span class="comment">//迭代的次数(再次加盐)  迭代太多，效率会有影响</span></span><br><span class="line">        md52 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;sxt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111==&quot;</span> + md52);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义Realm   加盐之后和之前自定义Realm的不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">//进行比较交给SimpleAuthenticationInfo info去和数据库中的信息作比较</span></span><br><span class="line">                <span class="comment">//加盐处理：ByteSource.Util.bytes(&quot;sxt&quot;)</span></span><br><span class="line">                SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(authenticationToken.getPrincipal(), rs.getString(<span class="string">&quot;pwd&quot;</span>), ByteSource.Util.bytes(<span class="string">&quot;sxt&quot;</span>), <span class="string">&quot;userRealm&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> info;<span class="comment">//用户信息</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>shiro.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#设置securityManager中的realm</span><br><span class="line">credentialMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">#设置加密类型</span><br><span class="line">credentialMatcher.hashAlgorithmName=md5</span><br><span class="line">#设置迭代次数</span><br><span class="line">credentialMatcher.hashIteration=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 因为自定义的UserRealm继承了AuthorizingRealm ，所以先设置AuthorizingRealm 这个里面的credentialMatcher的属性，然后再赋给UserRealm即可</span><br><span class="line">userRealm=com.bjsxt.shiro03.UserRealm</span><br><span class="line">userRealm.credentialMatcher=$credentialMatcher</span><br><span class="line">securityManager.realms=$userRealm</span><br></pre></td></tr></table></figure>
<h2 id="十-授权"><a href="#十-授权" class="headerlink" title="十. 授权"></a>十. 授权</h2><ol>
<li>授权:给身份认证通过的任授予某些资源的访问权限</li>
<li>权限的粒度： 粗粒度 细粒度<br><strong>粗粒度</strong><br>User 具有 CRUD 的操作 通常指的是表的操作<br><strong>细粒度</strong><br>只允许查询 id=1 的用户 使用业务代码实现<br><strong>Shiro 的授权是粗粒度</strong><br><strong>角色</strong>：角色就是权限的集合</li>
<li>Shiro 中代码的实现<br>详细见代码<br>Shiro 中的授权检查的 3 种方式</li>
</ol>
<ul>
<li><p> <strong>编程式</strong></p>
</li>
<li><p><strong>注解式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.annotation.RequiresRoles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*注解式授权*/</span></span><br><span class="line">    <span class="meta">@RequiresRoles(&quot;管理员&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>标签配置</strong>  用在web项目里面 jsp页面</p>
<figure class="highlight erb"><table><tr><td class="code"><pre><span class="line"><span class="xml">&lt;%</span><span class="ruby">@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml">&lt;%</span><span class="ruby"><span class="variable">@taglib</span> prefix=<span class="string">&quot;shiro&quot;</span> uri=<span class="string">&quot;http://shiro.apache.org/tags&quot;</span> </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">&lt;%-</span><span class="ruby">-标签式授权-</span><span class="xml">-%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>添加操作<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>授权详细代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjsxt.shiro1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1]解析shiro-jdbc.ini文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//[2]通过SecurityManager工厂获得SecurityMananger的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//[3]把SecurityManager对象设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//[4]通过SecurityUtils获得主题subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//[5]书写自己输入的账号和密码---相当于用户自己输入的账号和密码</span></span><br><span class="line">        <span class="comment">//我们拿着自己书写用户名和密码去和shiro.ini文件中的账号和密码比较</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;zs&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//[6]进行身份的验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//[7]通过方法判断是否登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;<span class="comment">/*catch (AuthenticationException e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;登陆失败&quot;);</span></span><br><span class="line"><span class="comment">            e.printStackTrace();//打印错误信息</span></span><br><span class="line"><span class="comment">        &#125;*/</span> <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凭证不正确&quot;</span>);</span><br><span class="line">            <span class="comment">/*使用shiro做异常处理的时候，尽量把异常信息表示的婉转一下。这样有助于提升代码的安全性*/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权的查询</span></span><br><span class="line">        <span class="comment">//基于角色的授权   查询单个subject.hasRole()</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = subject.hasRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个角色   subject.hasRoles()</span></span><br><span class="line">        <span class="keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (Boolean b : booleans) &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以使用checkRole判断指定用户是否具有对应角色</span></span><br><span class="line">        <span class="comment">//如果没有指定角色就会抛出异常UnauthorizedException   有的话就不报异常</span></span><br><span class="line">        subject.checkRole(<span class="string">&quot;role1&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个角色</span></span><br><span class="line">        subject.checkRoles(<span class="string">&quot;role1&quot;</span>, <span class="string">&quot;role3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基于资源的授权  看这个用户下有没有对应的菜单</span></span><br><span class="line">        <span class="keyword">boolean</span> flag2 = subject.isPermitted(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        System.out.println(flag2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否具有多个资源</span></span><br><span class="line">        <span class="keyword">boolean</span> permittedAll = subject.isPermittedAll(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;oo&quot;</span>, <span class="string">&quot;ii&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过checkPermission进行判断指定用户下是否有指定的资源</span></span><br><span class="line">        <span class="comment">//如果没有就会抛出异常</span></span><br><span class="line">        subject.checkPermission(<span class="string">&quot;uu&quot;</span>);</span><br><span class="line">        <span class="comment">//判断多个</span></span><br><span class="line">        subject.checkPermissions(<span class="string">&quot;uu&quot;</span>, <span class="string">&quot;oo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>shio.ini文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#指定具体的用户</span><br><span class="line">[users]</span><br><span class="line">#role给用户赋予角色  授权</span><br><span class="line">zs=<span class="number">123</span>,role1,role2</span><br><span class="line">sxt=root</span><br><span class="line"></span><br><span class="line">#角色的定义</span><br><span class="line">[roles]</span><br><span class="line">role1=add,update,delete</span><br><span class="line">role2=find</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#给对象中的属性赋值</span><br><span class="line">[main]</span><br></pre></td></tr></table></figure>
<p>  <strong>自定义 Realm  实现授权</strong><br>      我们仅仅通过配置文件指定授权是非常的不灵活的，在实际的应用中我们是将用户的信息和合权限信息保存到数据库中，我们是从数据库中获得用户的信息 ，使用 JDBCRealm 进行授权 。使用 JDBCRealm 操作的时候也不是很灵活。所以我们一般使用自定义 Realm 实现授权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义realm完成授权：shiro底层自己封装的数据库的表名称和字符的名称，这样就造成了使用起来非常不方便</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用户登陆名</span></span><br><span class="line">        String username = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">        <span class="comment">//获得username，然后去数据库查询这个用户对应的角色，再根据角色查询出指定角色下对应的菜单</span></span><br><span class="line">        <span class="comment">//返回给指定角色下的所有菜单---List集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟数据库查询到该用户所对应的菜单</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;updateUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;deleteUser&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;addUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">            simpleAuthorizationInfo.addStringPermission(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shiro的基础知识</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2021/03/24/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><pre><code>SQL注入攻击就是攻击者把SQL命令插入到web表单的输入域（比如登录页面或查询框）与或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。</code></pre>
<p>比如select * from user where id=1**‘ or 1=’**1 ——万能密码<br><img src="https://img-blog.csdnimg.cn/2021032218370159.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="SQL注入万能密码"><a href="#SQL注入万能密码" class="headerlink" title="SQL注入万能密码"></a>SQL注入万能密码</h4><p><img src="https://img-blog.csdnimg.cn/20210322183719172.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>查询数据库分类</strong></p>
<ul>
<li><strong>数字型注入</strong>（select * from users where id=  <strong>x</strong>)</li>
<li><strong>字符型注入</strong>    (select * from users where id =  <strong>‘x’</strong>)</li>
<li><strong>搜索型注入</strong>    (select * from database.table where users like ‘<strong>%要查询的关键字%’</strong>)</li>
</ul>
<p><strong>分类</strong></p>
<p><strong>数据提交方式</strong></p>
<ul>
<li>get注入</li>
<li>post注入</li>
<li>http头部注入（user-agent、cookie、referer、host)</li>
</ul>
<p><strong>其余</strong></p>
<p>还有一些常见的数据库注入类型；报错注入、盲注、延时注入、宽字节注入、二次注入、堆叠注入等</p>
<p><strong>SQL注入的危害</strong></p>
<ol>
<li>攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露、</li>
<li>可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账户</li>
<li>如果网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违规信息等</li>
<li>经过提权等步骤，服务器最高权限被攻击者获取。攻击者可以远程控制服务器，安装后门，得以修改或控制操作系统。</li>
</ol>
<h4 id="自动化注入工具"><a href="#自动化注入工具" class="headerlink" title="自动化注入工具"></a>自动化注入工具</h4><p><strong>Havij</strong></p>
<p>是一款自动化的SQL注入工具，它能够帮助渗透测试人员发现和利用web应用程序的SQL注入漏洞。Havij不仅能够自动挖掘可利用的 SQL查询，还能够识别后台数据库类型、检索数据的用户名和密码hash、转储表和列、从数据库中提取数据，甚至访问底层文件系统和执行系统命令，当然前提是有一个可利用的SQL注入漏洞。Havij支持广泛的数据库系统，如MsSQL，Mysql，MSAccess and Oracle。Havij支持参数配置以躲避IDS，支持代理，后台登录地址扫描。</p>
<p><strong>Sqlmap</strong></p>
<p>是一个自动SQL注入工具其可胜任执行一个广泛数据库管理系统后端指纹，检索DBMS数据库，usernames、表格、列、并列举整个DBMS信息。sqlmap提供转储数据库表以及Mysql、PostgreSQL、SQL Server服务器下载或上传任何文件并执行任意代码的能力</p>
<p><strong>The Mole</strong></p>
<p>是一款开源的 自动化SQL注入工具，其可绕过IPS/IDS(入侵防御系统/入侵检测系统)/只需提供一个URL和一个可用的关键字，他就能检测诸如点并利用。The Mole可以使用union注入技术和基于逻辑查询的注入技术。The Mole攻击范围包括SQL Server、MySQL、Postgres和Oracle数据库。</p>
<h3 id="手动注入的过程"><a href="#手动注入的过程" class="headerlink" title="手动注入的过程"></a>手动注入的过程</h3><ul>
<li>判断是否存在注入点 and 1=1和and 1=2或者单引号</li>
<li>判断字段长度 通过order by 长度一般是5开始</li>
<li>判断字段回显位置 使用union select  1,2,3,4字段长度</li>
<li>拿数据（库表字段数据）比如version() 、database()、table_name    table_schema</li>
</ul>
<p>group_concat(table_name,password)</p>
<h3 id="手工暴错注入"><a href="#手工暴错注入" class="headerlink" title="手工暴错注入"></a>手工暴错注入</h3><p>updatexml(1,concat(0x7e </p>
<h3 id="盲注-就是不断尝试、猜想"><a href="#盲注-就是不断尝试、猜想" class="headerlink" title="盲注(就是不断尝试、猜想)"></a>盲注(就是不断尝试、猜想)</h3><p><strong>盲注函数</strong></p>
<p><strong>MID(column_name,start[,length])</strong></p>
<p><strong>string substr(string,start,length)</strong></p>
<p><strong>Left(string,n)</strong></p>
<p>比如 id=1’ and left(version(),1)=5–+</p>
<h3 id="攻击特征"><a href="#攻击特征" class="headerlink" title="攻击特征"></a>攻击特征</h3><h4 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h4><ul>
<li><p><strong>#</strong></p>
</li>
<li><p><strong>–</strong></p>
</li>
<li><p><strong>/</strong>/**</p>
</li>
<li><p><strong>#</strong></p>
</li>
<li><p><strong>–+</strong></p>
</li>
</ul>
<p>防护工具——<strong>安全狗</strong></p>
<h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul>
<li><p>严格限制web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。</p>
</li>
<li><p>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型</p>
</li>
<li><p>对进入数据库的特殊字符(“  ‘  \ 尖括号 &amp; *；等   “)进入转义处理，或编码转换</p>
<p>text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理。</p>
</li>
<li><p>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，既不要直接拼接SQL语句</p>
</li>
<li><p>在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap等</p>
</li>
<li><p>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入</p>
<h3 id="注入工具介绍"><a href="#注入工具介绍" class="headerlink" title="注入工具介绍"></a>注入工具介绍</h3><p><strong>sqlmap</strong></p>
</li>
</ul>
<p>sqlmap是一个开源的渗透工具，它可以自动化检测和利用SQL注入缺陷以及接管数据库服务器的过程。他有一个强大的检测引擎，许多适合于终极渗透测试的小众特性和广泛的开关，从数据库指纹、从数据库获取数据到访问底层文件系统和通过带外连接在操作系统上执行命令。</p>
<h3 id="SQL注入的参数"><a href="#SQL注入的参数" class="headerlink" title="SQL注入的参数"></a>SQL注入的参数</h3><ul>
<li><p>-u  #注入点</p>
</li>
<li><p>-g  谷歌搜索</p>
</li>
<li><p>-f  #指纹判别数据库版本信息</p>
</li>
<li><p>-p  #指定可测试的参数(?page=1 &amp; id=2 -p “page,id”)</p>
</li>
<li><p>-D “ ” #指定数据库名</p>
</li>
<li><p>-T  “ “#指定表名</p>
</li>
<li><p>-C   “ ” #指定字段</p>
</li>
<li><p>-s   “ ”  #保存注入过程到一个文件，还可中断，下次恢复在注入（保存：-s”xx.log”    恢复：-s “xx.log” -resume)</p>
</li>
<li><p>-columns  #列出字段</p>
</li>
<li><p>-current -user   #获取当前用户名称</p>
</li>
<li><p>-current -db      #获取当前数据库名称</p>
</li>
<li><p>-users  # 列数据库所有用户</p>
</li>
<li><p>-passwords  #数据库用户所有密码</p>
</li>
<li><p>-privileges  #查看用户权限(-privileges -U root)</p>
</li>
<li><p>-U  #指定数据库用户</p>
</li>
<li><p>-dbs  #列出所有数据库</p>
</li>
<li><p>-tables -D  “ “ #列出指定数据库中的表</p>
</li>
<li><p>-columns -T “user” -D  “mysql”  #列出mysql数据库中的user表中的所有字段</p>
</li>
<li><p>-dump-all  #列出所有数据库所有表</p>
</li>
<li><p>-exclude -sysdbs  #只列出用户自己新建的数据库和表</p>
</li>
<li><p>-dump -T “ “ -D “ “ -C  ” “  #列出指定数据库的表的字段的数据(-dump -T users -D master -C surname)</p>
</li>
<li><p>-dump -T “” -D -start 2 -top 4  #列出指定数据库的表的2-4字段的数据</p>
<ul>
<li>-dbms #指定数据库(MySQL，Oracle，PostgreSQL,Microsoft SQL，Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)</li>
</ul>
</li>
<li><p>-os  #指定系统（Linux，Windows）</p>
</li>
<li><p>–sql -shell 写shell</p>
</li>
<li><p>–delay 延迟时间</p>
</li>
<li><p>-m  可以执行多个url</p>
</li>
<li><p>–level 3 –risk 5等级</p>
</li>
<li><p>sqlmap -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -f -b -current -user</p>
</li>
<li><p>-currernt-db -v 1</p>
</li>
<li><p>sqlmap -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -dbs -v 2</p>
</li>
<li><p>sqlmap  -u http;//<a href="http://www.evil0x.com/test.php%E2%9D%93p=2">www.evil0x.com/test.php❓p=2</a> -dump -D mysql -T</p>
</li>
<li><p>users -C ‘’username,password’ -s ‘’sqlnmapdb.log’’ -v 2</p>
</li>
</ul>
]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2021/03/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><strong>什么是文件上传？</strong></p>
<p>​    上传漏洞这个顾名思义，就是攻击者通过上传木马文件，直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。</p>
<p>​    导致该漏洞的原因在于代码作者<strong>没有对访客提交的数据进行检验或者过滤不严</strong>，可以直接提交修改过的数据绕过<strong>扩展名的检验</strong>。</p>
<p><strong>什么是webshell?</strong></p>
<p>​    webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称作为一种网页后门。黑客在入侵一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得<strong>到一个命令执行环境，以达到控制网站服务器的目的。</strong></p>
<p>顾名思义，“web”的含义是显然需要服务器开放web服务，<strong>“shell”的含义是取得对服务器某种程度上操作权限</strong>。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以<strong>动态脚本</strong>的形式出现，也有人称之为<strong>网站的后门工具。</strong></p>
<p><strong>什么是中间件？</strong></p>
<p>​    中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯。<strong>是连接两个独立应用程序或独立系统的软件</strong>。相连接的系统，即使他们具有不同的接口，但通过中间件相互之间仍能交互信息。</p>
<p>执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p>
<p>中间件是<strong>介于操作系统和应用软件之间</strong>，为应用软件提供服务功能的软件，有消息中间件、交易中间件、应用服务器等。由于介于两种软件之间，称为中间件。</p>
<p><strong>为什么使用中间件？</strong></p>
<p>具体地说，中间件<strong>屏蔽了底层操作系统的复杂性</strong>，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，<strong>将注意力集中在自己的业务上</strong>，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p>
<p><strong>常见中间件：Apache、Nginx、Tomcat、Weblogic等</strong></p>
<h3 id="文件上传分类"><a href="#文件上传分类" class="headerlink" title="文件上传分类"></a>文件上传分类</h3><ul>
<li><p><strong>客户端JS绕过(前端)</strong></p>
</li>
<li><p><strong>服务器端漏洞(后端)</strong></p>
<p><img src="C:\Users\Administrator\Desktop\360截图20210322195235414.jpg"></p>
</li>
</ul>
<p><strong>举例：</strong></p>
<h4 id="0x01-客户端验证绕过-javascript-扩展名检测-——js绕过"><a href="#0x01-客户端验证绕过-javascript-扩展名检测-——js绕过" class="headerlink" title="0x01   客户端验证绕过(javascript 扩展名检测)——js绕过"></a>0x01   客户端验证绕过(javascript 扩展名检测)——<strong>js绕过</strong></h4><p>打开http反向代理工具  burp</p>
<p>先随便点击上传一个2012.asa</p>
<p>然后还没点击Upload</p>
<p>burp里也还没出现任何内容</p>
<p>便弹出一个警告框‘</p>
<p>一看就知道是个客户端验证JavaScript</p>
<p>只需要把他禁掉或者通过burp进行代理修改  可以在火狐按住F12可以在js那行把我们想要的那个添加或者删除掉就可以  </p>
<p>这里我用burp进行代理修改</p>
<p>先将文件扩展名改成.jpg</p>
<p>然后Upload</p>
<p>现在的文件名是2012.jpg</p>
<p>在burp里将jpg改成.asp</p>
<p>然后继续上传</p>
<p>最后可以看到asp成功上传</p>
<h4 id="0x02-服务端验证绕过-http-request包检测"><a href="#0x02-服务端验证绕过-http-request包检测" class="headerlink" title="0x02  服务端验证绕过(http request包检测)"></a>0x02  服务端验证绕过(http request包检测)</h4><p>-Content-type(Mime-type)  检测</p>
<p>假如服务器端代码如下</p>
<p><img src="C:\Users\Administrator\Desktop\360截图20210322200148498.jpg"></p>
<p><img src="C:\Users\Administrator\Desktop\2.jpg"></p>
<h4 id="服务器验证绕过（扩展名检测）"><a href="#服务器验证绕过（扩展名检测）" class="headerlink" title="服务器验证绕过（扩展名检测）"></a>服务器验证绕过（扩展名检测）</h4><p>黑名单检测</p>
<p>黑名单的安全性其实还没白名单的安全性高，至少攻击他的方式比白名单多多了</p>
<p>一般有个专门的blacklist文件，里面会包含常见的危险脚本文件</p>
<p>例如 fckeditor 2.4.3或之前版本的黑名单</p>
<p><img src="C:\Users\Administrator\Desktop\5.jpg"></p>
<h4 id="0x00截断绕过-—这个是基于一个组合逻辑漏洞造成的"><a href="#0x00截断绕过-—这个是基于一个组合逻辑漏洞造成的" class="headerlink" title="0x00截断绕过  —这个是基于一个组合逻辑漏洞造成的"></a>0x00截断绕过  —这个是基于一个组合逻辑漏洞造成的</h4><p>给个简单的伪代码</p>
<p>name=getname(http request)  //假如这时候获取到的文件名是help.asp .jpg（asp后面为0x00)  type=gettype(name)  //而在<strong>gettype()函数里处理方式是从后往前扫描扩展名，</strong>所以判断为jpg</p>
<p>if(type==jpg)</p>
<p>​    SaveFileToPath(UploadPath.name,name)  //但在这里却是以0x00作为文件名截断</p>
<p>//最后以help.asp存入路径里</p>
<h4 id="双扩展名解析绕过攻击-1-—基于web服务的解析逻辑"><a href="#双扩展名解析绕过攻击-1-—基于web服务的解析逻辑" class="headerlink" title="双扩展名解析绕过攻击(1)—基于web服务的解析逻辑"></a>双扩展名解析绕过攻击(1)—基于web服务的解析逻辑</h4><p>如果上传一个文件名为help.asp.123</p>
<p>首先扩展名123并没有在扩展名blacklist里，然后扩展名123也没在apache可解析扩展名list里，这个时候它会向前搜索下一个可解析扩展名，或搜寻到  .php，最后会以php执行</p>
<h4 id="双扩展名解析绕过攻击-1-—基于web服务的解析方式"><a href="#双扩展名解析绕过攻击-1-—基于web服务的解析方式" class="headerlink" title="双扩展名解析绕过攻击(1)—基于web服务的解析方式"></a>双扩展名解析绕过攻击(1)—基于web服务的解析方式</h4><p>如果在apache的conf里有这样一行配置</p>
<p>AddHandler php5-script.php</p>
<p>这时只要文件名里包含.php</p>
<p>即使文件名是test2.php.jpg也会以php来执行</p>
<h4 id="危险解析绕过攻击—基于web服务的解析方式"><a href="#危险解析绕过攻击—基于web服务的解析方式" class="headerlink" title="危险解析绕过攻击—基于web服务的解析方式"></a>危险解析绕过攻击—基于web服务的解析方式</h4><p>如果在apache的conf里有这样一行配置</p>
<p>AddType applications-httpd-php.jpg</p>
<p>即使扩展名是.jpg，一样能以php方式执行</p>
<h3 id="白名单检测"><a href="#白名单检测" class="headerlink" title="白名单检测"></a>白名单检测</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p>
<ol>
<li><p>特别文件名构造(同黑名单攻击第三条)</p>
</li>
<li><p>IIS或nginx文件名解析漏洞(同黑名单攻击第四条)</p>
</li>
<li><p>0x00截断绕过(同黑名单攻击第五条)</p>
<p>.htaccess文件攻击</p>
</li>
</ol>
<p>无论是黑名单还是白名单</p>
<p>再直接点就是直接攻击.htaccess文件</p>
<p>在PHP  manual中提到了下面一段话</p>
<p>move_uploaded_file section,ther is a warning which states</p>
<p>‘if the destination file already exists,it will be overwritten.’</p>
<p>如果PHP安全没配置好</p>
<p>就可以通过move_uploaded_file函数把自己写的.htaccess文件覆盖掉服务上的</p>
<p>这样就能任意定义解析名单了</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>客户端验证绕过(javascript扩展名检测)</p>
<p>用反向代理工具(burp之类)或禁用js便可以绕过客户端验证</p>
</li>
<li><p>服务端验证绕过(http request包检测)</p>
<p>-Content-type(Mime type)检测</p>
<p>用反向代理工具(burp之类的)进行Content-type伪造</p>
</li>
<li><p>服务端验证绕过(扩展名检测)</p>
<p>-<strong>黑名单检测</strong></p>
<p>找黑名单扩展名的漏网之鱼–比如上面就漏掉了asa和cer之类</p>
<p>可能存在大小写绕过漏洞–比如aSp和pHp之类</p>
<p>特别文件名构造–比如发送的http包里把文件名改成help.asp或 help.asp_（下划线为空格)</p>
<p>IIS或nginx文件名解析漏洞—比如help.asp;.jpg或<a href="http://www.xx.com/help.jpg/2.php">http://www.xx.com/help.jpg/2.php</a></p>
<p>0x00截断绕过–这个是基于一个组合逻辑漏洞造成的</p>
<p>双扩展名解析绕过攻击(1)–基于web服务的解析逻辑</p>
<p>双扩展名解析绕过攻击(2)–基于web服务的解析方式</p>
<p>危险解析绕过攻击–基于web服务的解析方式</p>
<p>–<strong>白名单检测</strong></p>
<p>特别文件名构造(同黑名单攻击第3条)</p>
<p>IIS或nginx文件名解析漏洞(同黑名单攻击第4条)</p>
<p>0x00截断绕过(同黑名单攻击第5条)</p>
<p>-<strong>.htaccess文件名攻击</strong></p>
<p>在PHP安全没配置好的情况下，用自己的.htaccess覆盖服务上原文件</p>
</li>
<li><p>服务端验证绕过(文件完整性检测)</p>
<p>-<strong>文件头检测</strong></p>
<p>在文件开始伪装文件的幻数</p>
<p>-<strong>图像分辨率检测</strong></p>
<p>在文件开始伪装图像大小数据</p>
<p>-<strong>文件加载检测</strong></p>
<p>用工具对文件空白数据区或注释区进行代码注入绕过</p>
<p>(图像仅能绕过渲染测试，而不能绕过二次渲染)</p>
<p>用恶意文件去攻击加载器本身</p>
</li>
<li><p>相互关系与组合情况</p>
<p>首先客户端验证和服务端验证是相互独立的，所以分开绕过就行了</p>
<p>主要难点是在服务端验证的组合上</p>
<p>文件完整性检测已经包含文件头检测和图像大小及相关信息检测，但不包含文件扩展名检测</p>
<p>它是以加载来作为检测的方式，比如用图像渲染函数去渲染一张图片</p>
<p>文件扩展名检测和文件头都是同级的，相互独立</p>
<p>所以如果是文件扩展名+文件头检测可以同时分开绕过</p>
<p>-<strong>IIS文件名，解析漏洞</strong></p>
<p>漏洞描述</p>
<p>当文件名为[YYY].asp；[ZZZ].jpg时，Microsoft IIS会自动以asp格式来进行解析。</p>
<p>而当文件名为[YYY].php；[ZZZ].jpg时，Microsoft IIS会自动以php格式来进行解析。</p>
<p>其中[YYY]与[ZZZ]处可为变化字符串</p>
<p>影响平台：</p>
<ol>
<li><p>等待微软相关的补丁包</p>
</li>
<li><p>关闭图片所在目录的脚本执行权限(前提是你的某些图片没有与程序混合存放)</p>
</li>
<li><p>校验网站程序中所有上传图片的代码段，对形如[YYY].asp；[ZZZ].jpg的图片做拦截</p>
<p>备注:</p>
<p>对于Windows server 2008(IIS7)以及Windows server 2008 R2(IIS7.5)则未受影响</p>
<p><strong>文件类型解析。IIS6.0默认的可执行文件处了.asp，还包括.asa、.cdx、.cer</strong></p>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>xss漏洞</title>
    <url>/2021/03/24/xss%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>简介</p>
<p><strong>XSS作为OWASP TOP10之</strong>一，中文叫做<strong>跨站脚本攻击</strong>Cross-site scripting,本来应该缩写为CSS，但由于和CSS【Cascading Style Sheets,层叠样式脚本】重名，所以更名为XSS。XSS跨站脚本攻击主要基于JavaScript简称JS来完成恶意的攻击行为。</p>
<p>XSS是一种经常出现在web应用中的计算机安全漏洞，也是web中最主流的攻击方式。</p>
<p><strong>概念</strong></p>
<ul>
<li>XSS是指恶意攻击者利用网站<strong>没有对用户提交数据进行转义处理或者过滤不足</strong>的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。</li>
<li>从而获取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</li>
</ul>
<p><strong>XSS原理</strong></p>
<p>利用我们所知道的各种黑魔法，向web页面插入JS代码，让JS代码可以被浏览器执行，访问该页面的用户则被攻击</p>
<p><strong>针对用户</strong></p>
<ul>
<li>窃取cookie劫持会话</li>
<li>网络钓鱼</li>
<li>放马挖矿</li>
<li>广告刷流量</li>
</ul>
<p><strong>针对WEB服务</strong></p>
<ul>
<li>篡改页面</li>
<li><strong>劫持后台</strong></li>
<li>传播蠕虫</li>
<li><strong>内网扫描</strong></li>
</ul>
<p>攻击者的JS水平决定了攻击效果</p>
<h3 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h3><ul>
<li><p><strong>反射型</strong></p>
<p>反射型也称作非持久型，这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中</p>
</li>
<li><p><strong>存储型</strong></p>
<p>攻击者将已经构造完成的恶意页面发送给用户，用户访问看似正常的页面后收到攻击，这类XSS通常无法直接在URL中看到恶意代码，具有较强的持久性和隐蔽性</p>
</li>
<li><p><strong>DOM型</strong></p>
<p>DOM型XSS<strong>无需和后端交互</strong>，而是基于JavaScript上，JS解析        URL中恶意参数导致执行JS代码。</p>
</li>
</ul>
<p><strong>存储型的XSS危害是最大的</strong></p>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><ul>
<li><p>持久性，代码是存储在web服务器中的，比如在个人信息或发表文章等地方插入代码，如果没有过滤或过滤不严，那么这些代码将存储在服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫】盗窃cookie。每一个访问特定页面的用户，都会受到攻击。</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>XSS攻击代码存储在web server上</p>
</li>
<li><p>攻击者，一般是通过网站的留言、评论、博客、日志等等功能（所有能够向web server输入内容的地方）将攻击代码存储在web server上的<br><img src="https://img-blog.csdnimg.cn/20210322183454829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><ul>
<li>发射型跨站脚本也称作非持久型、参数型跨站脚本、这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中</li>
<li>例如</li>
<li><a href="http://www.test.com/search.php?key=&#39;&#39;&gt;">http://www.test.com/search.php?key=&#39;&#39;&gt;</a>&lt; script&gt;  alert(‘’xss’’) </script></li>
<li>一般使用的将构造好的URL发给受害者，是受害者点击触发，而且只执行一次，非持久化。<br><img src="https://img-blog.csdnimg.cn/20210322183424120.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h3><p>JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。他的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML(标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。</p>
<h3 id="XSS防御与发现"><a href="#XSS防御与发现" class="headerlink" title="XSS防御与发现"></a>XSS防御与发现</h3><ul>
<li><p>HTML节点内容的XSS防御</p>
<p>转义掉&lt;&lt;和&gt;&gt;即转移掉&lt;&gt;即可，转义的时机有两种，一种是写入数据库的时候进行转义，另一种是在解析的时候进行转义</p>
<p>这里是在显示的时候转义</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtml=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>HTML属性的XSS防御</p>
<p>转义”&amp;quto”；即转义掉双引号，‘转移掉单引号，另一个要注意的是实际上html的属性可以不包括引号，因此严格的说我们还需要对空格进行转义，但是这样会导致渲染的时候空格数不对，因此我们不转义空格，然后再写html属性的时候全部带上引号）这样属性就不会被提前关闭了</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	str =str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;&amp;quto;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&#x27;/g</span>,<span class="string">&#x27;&amp;#39;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/ /g</span>,<span class="string">&#x27;&amp;#32;&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure>
<p>其实以上这两个函数可以合并成一个函数，这样不管是内容还是属性都可以使用一个函数来过滤了</p>
<h5 id="html转义函数"><a href="#html转义函数" class="headerlink" title="html转义函数"></a>html转义函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	str =str.replace(<span class="regexp">/&amp;/g</span>,<span class="string">&#x27;&amp;amp;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;&amp;quto;&#x27;</span>);</span><br><span class="line">	str =str.replace(<span class="regexp">/&#x27;/g</span>,<span class="string">&#x27;&amp;#39;&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">escapeHtml(content);</span><br></pre></td></tr></table></figure></li>
<li><p>js转义</p>
<p>转义“\”  或者替换成json</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeForJS=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	str=str.replace(<span class="regexp">/\\/g</span>,<span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">	str=str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的解决方式并不完整，因为还有可能是单引号或者其他形式包裹的，这里最保险的方法其实很简单，就是对数据做一次JSON，stringify即可</p>
</li>
<li><p>富文本</p>
<p>由于需要完整的HTML因此不太容易过滤，一般是按照白名单进行保留部分标签和属性来进行过滤，除了允许的标签和属性，其他的全部不允许（也有黑名单的方式，但是由于html复杂效果比较差，原理就是之前的正则替换）</p>
<p>其实可以用别人写好的XSS组件就叫做XSS，直接</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> xss</span><br></pre></td></tr></table></figure>
<p>白名单—-使用第三方库XSS，支持指定白名单</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">var xssFilter=function(html)&#123;</span><br><span class="line">	if(!html) return &#x27;&#x27;;</span><br><span class="line">	var xss=require(&#x27;xss&#x27;);</span><br><span class="line">	var ret=xss.(html,&#123;</span><br><span class="line">		whiteList;&#123;</span><br><span class="line">			img;[&#x27;src&#x27;],</span><br><span class="line">			a;[&#x27;href&#x27;].</span><br><span class="line">			font;[&#x27;size&#x27;,&#x27;color&#x27;]</span><br><span class="line">		&#125;,</span><br><span class="line">        onIgnoreTag;function()&#123;</span><br><span class="line">        	return &#x27;&#x27;;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(html,ret);</span><br></pre></td></tr></table></figure>
<h3 id="Pikachu靶场上的漏洞类型列表如下："><a href="#Pikachu靶场上的漏洞类型列表如下：" class="headerlink" title="Pikachu靶场上的漏洞类型列表如下："></a>Pikachu靶场上的漏洞类型列表如下：</h3><ul>
<li><p>Burt Force（暴力破解漏洞）</p>
</li>
<li><p>XSS（跨站脚本漏洞）</p>
</li>
<li><p>CSRF（跨站请求伪造）</p>
</li>
<li><p>SQL-Inject（SQL注入漏洞）</p>
</li>
<li><p>RCE（远程命令/代码执行）</p>
</li>
<li><p>Files Inclusion（文件包含漏洞）</p>
</li>
<li><p>Unsafe file downloads（不安全的文件下载）</p>
</li>
<li><p>Unsafe file uploads（不安全的文件上传）</p>
</li>
<li><p>Over Permisson（越权漏洞）</p>
</li>
<li><p>../../../（目录遍历）</p>
</li>
<li><p>I can see your ABC（敏感信息泄露）</p>
</li>
<li><p>PHP反序列化漏洞</p>
</li>
<li><p>XXE(XML External Entity attack)</p>
</li>
<li><p>不安全的URL重定向</p>
</li>
<li><p>SSRF（Server-Side Request Forgery）</p>
</li>
</ul>
</li>
</ul>
<h3 id="XSS蠕虫攻击"><a href="#XSS蠕虫攻击" class="headerlink" title="XSS蠕虫攻击"></a>XSS蠕虫攻击</h3><p>XSS蠕虫的破坏力和影响力都是巨大的。XSS蠕虫主要发生在用户之间存在交互行为的页面中，当web应用程序对用户输入的数据信息没有严格的过滤时，通过结合Ajax的异步提交，就可以实现在植入恶意代码的同时，将恶意代码进行对外发送，即实现了代码的感染和传播，也就形成了XSS蠕虫。</p>
<h3 id="挖掘XSS漏洞方法"><a href="#挖掘XSS漏洞方法" class="headerlink" title="挖掘XSS漏洞方法"></a>挖掘XSS漏洞方法</h3><ul>
<li><p><strong>扫描工具自动化检测</strong></p>
<p><strong>WVS</strong></p>
<p><strong>AppScan</strong></p>
<p><strong>JSky</strong></p>
</li>
<li><p><strong>手工测试</strong></p>
</li>
<li><p><strong>源码分析</strong></p>
</li>
</ul>
<h3 id="XSS跨站脚本攻击漏洞防范"><a href="#XSS跨站脚本攻击漏洞防范" class="headerlink" title="XSS跨站脚本攻击漏洞防范"></a>XSS跨站脚本攻击漏洞防范</h3><ul>
<li><strong>客户端用户</strong><ul>
<li>IE8及高版本，开启XSS筛选器功能</li>
<li>Firefox使用CSP、Noscript等扩展功能</li>
<li>瑞星个人防火墙2012版本开启XSS拦截功能</li>
</ul>
</li>
<li><strong>WEB应用程序员</strong><ul>
<li>使用HttpOnly</li>
<li>完整的输入、检出检查</li>
</ul>
</li>
</ul>
<p><strong>HttpOnly</strong></p>
<ul>
<li><p><strong>HttpOnly</strong>最初是由微软提出的，目前已经被多款流行浏览器厂商所采用。<strong>HttpOnly</strong>的作用不是过滤XSS跨站脚本攻击，而是浏览器将禁止页面的JavaScript访问带有<strong>HttpOnly</strong>属性的cookie,解决XSS跨站脚本攻击后的Cookie会话劫持行为</p>
</li>
<li><p><strong>HttpOnly</strong>是在Set-Cookie时进行标记的，设置的Cookie头格式如下：<br><img src="https://img-blog.csdnimg.cn/20210322183336920.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY1MTE1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>以php为例，在php 5.2版本时就已经在SetCookie函数加入了对HttpOnly的支持，如：</p>
<?php

        setcookie("user","admin",NULL,NULL,NULL,NULL,TRUE);

?>

<p>通过以上代码就可以设置user这个cookie，将其设置为HttpOnly,setcookie函数实质是通过向客户端发送原始的HTTP报文头进行设置的，document将不可见这个Cookie，所以使用document.cookie就取不到这个cookie，也就实现了对cookie的保护。</p>
</li>
<li><p><strong>输入、输出检查</strong></p>
<p>由于三种XSS跨站脚本攻击类型的漏洞成因可不相同，针对输入输出的检查一部分适用于反射型XSS与存储型XSS，而另外一些检查适用于基于DOM 的XSS</p>
<ul>
<li><p><strong>反射型和存储型XSS输入、输出检查</strong></p>
<ul>
<li><p><strong>输入检查</strong></p>
<p>在大多数的时候都是对可信字符的检查或输入数据格式的检查，如用户输入的注册账号信息中只允许包括字母、数字、下划线和汉字等，对于输入的<strong>一切非白名单</strong>的字符均认为是非法输入。数据格式如输入的IP地址、电话号码、邮件地址、日期等数据都具有一定的格式规范，只有符合数据规范的输入信息才允许通过检查</p>
<ul>
<li><p><strong>输出检查</strong></p>
<p>输出检查主要是针对数据展示过程中，应该对数据信息进行HTML<strong>编码</strong>处理，将可能存在导致XSS跨站脚本攻击的恶意字符进行编码，在不影响正常数据显示的前提条件下，<strong>过滤恶意字符</strong></p>
</li>
<li><p>常见的可能造成XSS跨站脚本攻击的字符及其HTML编码如下——<strong>输出检查</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&quot;    <span class="symbol">&amp;quot;</span></span><br><span class="line">&#x27;    <span class="symbol">&amp;apos;</span></span><br><span class="line">&amp;    <span class="symbol">&amp;amp;</span></span><br><span class="line">&lt;    <span class="symbol">&amp;lt;</span></span><br><span class="line">&gt;    <span class="symbol">&amp;gt;</span></span><br><span class="line">    除了常用的编码外，任何字符都可以使用其ASCLL码进行HTML编码，如</span><br><span class="line">    %    <span class="symbol">&amp;#37;</span></span><br><span class="line">    *    <span class="symbol">&amp;#42;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>DOM Based XSS 输入、输出检查</strong></p>
<ul>
<li><p><strong>特殊性</strong></p>
<p>基于DOM的XSS跨站脚本攻击发生时，恶意数据的格式与传统的XSS跨站脚本攻击数据格式有一定的差异，甚至可以在<strong>不经过服务器的处理和响应</strong>的情况下，直接对客户端实施攻击行为。</p>
</li>
<li><p><strong>输入检查</strong></p>
<p>在<strong>客户端</strong>部署相应的安全检测代码的过滤效果要比在服务器检测的效果更加明显</p>
<p>客户端检测代码来保证用户输入的数据只包含字母、数字和空格</p>
<p>在<strong>服务端</strong>实现上述数据检查的功能</p>
<ul>
<li>URL参数名称、个数检测</li>
<li>参数值类型及内容检测</li>
</ul>
</li>
<li><p><strong>输出检查</strong></p>
<ul>
<li>在将用户可控的DOM数据内容插入到文档之前，WEB应用程序应对提交的数据进行HTML编码处理，将用户提交的数据中可能存在的各种危险字符和表达式进行过滤以安全的方式插入到文档进行展示。</li>
</ul>
</li>
</ul>
<h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><ul>
<li><p><strong>网站安全狗</strong></p>
</li>
<li><p><strong>XSSer</strong></p>
<p>XSSer简称Cross site ‘scripter’是一款自动化渗透测试XSS漏洞的安全工具，专门用来<strong>检测和利用</strong>不同应用程序中存在的跨站脚本漏洞。它包含了一些选项用来尝试绕过特定的过滤器，并且具有特殊的代码注入技术。</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>命令执行漏洞</title>
    <url>/2021/03/24/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
